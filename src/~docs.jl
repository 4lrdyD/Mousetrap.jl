## Classification

widgets = Symbol[]
event_controllers = Symbol[]
signal_emitters = Symbol[]
abstract_types = Symbol[]
types = Symbol[]
functions = Symbol[]
enums = Symbol[]
enum_values = Symbol[]
other = Symbol[]

for n in names(mousetrap)

    binding = getproperty(mousetrap, n)

    if binding isa Type
        if isabstracttype(binding)
            push!(abstract_types, n)
        elseif binding <: Widget
            push!(widgets, n)
        elseif binding <: EventController
            push!(event_controllers, n)
        elseif binding <: SignalEmitter
            push!(signal_emitters, n)
        elseif binding <: Int64
            push!(enums, n)
        else
            push!(types, n)
        end
    elseif typeof(binding) <: Function
        if isnothing(match(r".*_signal_.*", string(binding))) # filter autogenerated signal functions
            if string(n)[1] != `@` # filter macros
                push!(functions, n)
            end
        end
    elseif typeof(binding) <: Int64
        push!(enum_values, n)
    else
        push!(other, n)
    end
end

## Functions

macro signature(return_t, args...)
    arg_list = ""
    n_args = length(args)
    for i in 1:n_args
        arg_list *= string(args[i])
        if i != n_args
            arg_list *= ", "
        end
    end
    return "($arg_list) -> $return_t"
end

struct FunctionDescriptor

    name::Symbol
    signature::String
    brief::String
    argument_briefs::Dict{Symbol, String}
end

function expand(f::FunctionDescriptor) ::String

    out = ""
    out *= "```\n"
    out *= "$(f.name)$(f.signature)\n"
    out *= "```\n"
    out *= "$(f.brief)\n"

    if isempty(f.argument_briefs)
        return out
    end

    out *= "## Arguments\n"

    for arg in f.argument_briefs
        out *= "+ `$arg`\n"
    end

    out *= "\n"
    return out
end

function _function(
    name::Symbol,
    signature::String = @signature(Cvoid),
    brief::String = "", 
    argument_briefs = Dict())

    return expand(FunctionDescriptor(
        name,
        signature,
        brief,
        argument_briefs
    ))
end

## Structs

struct SignalDescriptor
    id::Symbol
    signature::String
    emitted_when::String
end

struct TypeDescriptor
    name::Symbol
    super::Type
    brief::String
    signals::Vector{Symbol}
    constructors::Vector{String}
    fields::Dict{Symbol, Type}
    example::String

    function TypeDescriptor(name::Symbol;
        super = Any,
        brief = "",
        signals = Symbol[],
        constructors = String[],
        fields = Dict(),
        example = ""
    )
        return new(name, super, brief, signals, constructors, fields, example)
    end
end

function expand(type::TypeDescriptor)
    out = ""
    out *= "## $(type.name)" * (!isnothing(type.super) ? " <: " * string(type.super) : "") * "\n"
    out *= "$(type.brief)\n"

    out *= "## Constructors\n"
    if !isempty(type.constructors)
        for constructor in type.constructors
            out *= "+ `" * constructor * "`\n"
        end
    else
        out *= "(no public constructors)\n"
    end

    if !isempty(type.signals)
        out *= "## Signals\n"
        out = "| Signal ID | Signature | Emitted when...|\n|---|---|---|\n"
        for signal_id in signal_names
            descriptor = signal_descriptors[signal_id]
            out *= "| `" * string(descriptor.id) * "` | `(instance::" * string(object_name) * ", " * descriptor.signature * "` | " * descriptor.emitted_when * "|\n"
        end
    end

    out *= "## Fields\n"
    if !isempty(type.fields)
        for field in type.fields
            out *= "+ `" * string(field[1]) * "::" * string(field[2]) * "`\n"
        end
    else
        out *= "(no public fields)\n"
    end

    if !isempty(type.example)
        out *= "## Example\n"
        out *= "```julia\n$(type.example)\n```"
    end

    return out
end

## Enums

struct EnumDescriptor
    name::Symbol
    brief::String
    values::Vector{Symbol}

    EnumDescriptor(name::Symbol; brief::String = "", values::Vector{Symbol} = []) = new(name, brief, values)
end

function expand(enum::EnumDescriptor)
    out = ""
    out *= "## $(enum.name)\n"
    out *= "$(enum.brief)\n"
    out *= "## Enum Values\n"

    for value in enum.values
        out *= "+ `$value`\n"
    end

    return out
end

## Generate

macro document(name, text)
    return :(@doc $text $name)
end


####### signal_components.jl

    struct SignalDescriptor
        id::Symbol
        signature::String
        emitted_when::String
    end

    const signal_descriptors = Dict{Symbol, SignalDescriptor}()
    function add_signal(id::Symbol, signature::String, description::String)
        signal_descriptors[id] = SignalDescriptor(id, signature, description)
    end

    void_signature = "[::Data_t]) -> Nothing"

    add_signal(:activate, void_signature, "`Widget::activate()` is called or the widget is otherwise activated")
    add_signal(:startup,  void_signature, "`Application` is in the process of initializing")
    add_signal(:shutdown, void_signature, "`Application` is done initializing and will now start the main render loop")
    add_signal(:update, void_signature, "once per frame, at the start of each render loop")
    add_signal(:paint, void_signature, "once per frame, right before the associated widget is drawn")
    add_signal(:realize, void_signature, "widget is fully initialized and about to be rendered for the first time")
    add_signal(:unrealize, void_signature, "widget was hidden and will seize being displayed")
    add_signal(:destroy, void_signature, "A widgets ref count reaches 0 and its finalizer is called")
    add_signal(:hide, void_signature, "`Widget::hide``is called or a widget becomes no longer visible otherwise")
    add_signal(:show, void_signature, "widget is rendered to the screen for the first time")
    add_signal(:map, void_signature, "widgets size allocation was assigned")
    add_signal(:unmap, void_signature, "widget or one of its parents is hidden")
    add_signal(:close_request, "[::Data_t]) -> allow_close::WindowCloseRequestResult", "mousetrap or the users operating system requests for a window to close")
    add_signal(:close, void_signature, "popover is closed")
    add_signal(:activate_default_widget, void_signature, "widget assigned via Window::set_default_widget is activated is activated")
    add_signal(:activate_focused_widget, void_signature, "widget that currently holds focus is activated")
    add_signal(:clicked, void_signature, "user activates the widget by clicking it with a mouse or touch-device")
    add_signal(:toggled, void_signature, "buttons internal state changes")
    add_signal(:text_changed, void_signature, "underlying text buffer is modified in any way")
    add_signal(:selection_changed, "position::Integer, n_items::Integer, [::Data_t]) -> Nothing", "number or index of selected elements changes")
    add_signal(:key_pressed, "code::KeyCode, modifiers::ModifierState, [::Data_t]) -> should_invoke_default_handlers::Bool", "user pressed a non-modifier key")
    add_signal(:key_released, "code::KeyCode, modifiers::ModifierState, [::Data_t]) -> Nothing", "user releases a non-modifier key")
    add_signal(:modifiers_changed, "code::KeyCode, modifiers::ModifierState, [::Data_t]) -> Nothing", "user presses or releases a modifier key")
    add_signal(:drag_begin, "start_x::AbstractFloat, start_y::AbstractFloat, [::Data_t]) -> Nothing", "first frame at which a drag gesture is recognized")
    add_signal(:drag, "x_offset::AbstractFloat, y_offset::AbstractFloat, [::Data_t]) -> Nothing", "once per frame while a drag gesture is active")
    add_signal(:drag_begin, "x_offset::AbstractFloat, y_offset::AbstractFloat, [::Data_t]) -> Nothing", "drag gesture seizes to be active")
    add_signal(:click_pressed, "n_presses::Integer, x::AbstractFloat, y::AbstractFloat, [::Data_t]) -> Nothing", "User presses a mouse button or touch-device")
    add_signal(:click_released, "n_presses::Integer, x::AbstractFloat, y::AbstractFloat, [::Data_t]) -> Nothing", "User releases a mouse button or touch-device")
    add_signal(:clip_stopped, void_signature, "once when a series of clicks ends")
    add_signal(:focus_gained, void_signature, "Widget acquires input focus")
    add_signal(:focus_lost, void_signature, "Widget looses input focus")
    add_signal(:pressed, "x::AbstractFloat, y::AbstractFloat, [::Data_t]) -> Nothing", "long-press gesture is recognized")
    add_signal(:press_cancelled, void_signature, "long-press gesture seizes to be active")
    add_signal(:motion_enter, "x::AbstractFloat, y::AbstractFloat, [::Data_t]) -> Nothing", "cursor enters allocated area of the widget for the first time")
    add_signal(:motion_enter, "x::AbstractFloat, y::AbstractFloat, [::Data_t]) -> Nothing", "once per frame while cursor is inside allocated area of the widget")
    add_signal(:motion_enter, void_signature, "cursor leaves allocated area of the widget")
    add_signal(:scale_changed, "scale::AbstractFloat, [::Data_t]) -> Nothing", "distance between two fingers recognized as a pinch-zoom-gesture changes")
    add_signal(:rotation_changed, "angle_absolute_radians::AbstractFloat, angle_delta_radians::AbstractFloat, [::Data_t]) -> Cvoid", "angle between two fingers recognized as a rotate-gesture changes")
    add_signal(:scroll_begin, void_signature, "user initiates a scroll gesture using the mouse scrollwheel or a touch-device")
    add_signal(:scroll, "x_delta::AbstractFloat, y_delta::AbstractFloat, [::Data_t]) -> also_invoke_default_handlers::Bool", "once per frame while scroll gesture is active")
    add_signal(:scroll_end, void_signature, "user seizes scrolling")
    add_signal(:kinetic_scroll_decelerate, "x_velocity::AbstractFloat, y_velocity::AbstractFloat, [::Data_t]) -> Cvoid", "widget is still scrolling due to scrolling \"inertia\"")
    add_signal(:stylus_down, "x::AbstractFloat, y::AbstractFloat, [::Data_t]) -> Cvoid", "stylus makes physical contact with the touchpad")
    add_signal(:stylus_up, "x::AbstractFloat, y::AbstractFloat, [::Data_t]) -> Cvoid", "stylus seizes to make contact with the touchpad")
    add_signal(:proximity, "x::AbstractFloat, y::AbstractFloat, [::Data_t]) -> Cvoid", "stylus enters or leaves maximum distance recognized by the touchpad")
    add_signal(:swipe, "x_velocity::AbstractFloat, y_velocity::AbstractFloat, [::Data_t]) -> Cvoid", "swipe gesture is recognized")
    add_signal(:pan, "::PanDirection, offset::AbstractFloat, [::Data_t]) -> Cvoid", "pan gesture is recognized")
    add_signal(:value_changed, void_signature, "`value` property of underlying adjustment changes")
    add_signal(:properties_changed, void_signature, "any property other than `value` of underlying adjustment changes")
    add_signal(:wrapped, void_signature, "`SpinButton` for whom `is_wrapped` is enabled has its value increased or decreased past the given range")
    add_signal(:scroll_child, "::ScrollType, is_horizontal::Bool, [::Data_t]) -> Cvoid", "user triggers a scroll action")
    add_signal(:resize, "width::Integer, height::Integer, [::Data_t]) -> void", "allocated size of `RenderArea` changes while it is realized")
    add_signal(:activated, void_signature, "`Action` is activated")
    add_signal(:revealed, void_signature, "child is fully revealed (after the animation has finished)")
    add_signal(:page_reordered, "page_index::Integer, [::Data_t]) -> Cvoid", "page of `Notebook` changes position")
    add_signal(:page_added, "page_index::Integer, [::Data_t]) -> Cvoid", "number of pages increases while the widget is realized")
    add_signal(:page_reordered, "page_index::Integer, [::Data_t]) -> Cvoid", "number of pages decreases while the widget is realized")
    add_signal(:page_reordered, "page_index::Integer, [::Data_t]) -> Cvoid", "currently visible page changes")
    add_signal(:items_changed, "position::Integer, n_removed::Integer, n_added::Integet, [::Data_t]) -> Cvoid", "list of items is modified")

    function generate_signal_table(object_name::Symbol, signal_names::Symbol...) ::String
        out = "| Signal ID | Signature | Emitted when...|\n|---|---|---|\n"
        for signal_id in signal_names
            descriptor = signal_descriptors[signal_id]
            out *= "| `" * string(descriptor.id) * "` | `(instance::" * string(object_name) * ", " * descriptor.signature * "` | " * descriptor.emitted_when * "|\n"
        end
        return out;
    end

    macro signature(function_name, return_t, args...)
        arg_list = ""
        n_args = length(args)
        for i in 1:n_args
            arg_list *= string(args[i])
            if i != n_args
                arg_list *= ", "
            end
        end
        return "```\n$function_name($arg_list) -> $return_t\n```"
    end

    macro document(object, string)
        out = Expr(:block)
        push!(out.args, :(@doc($string, $object)))
        return out
    end

    const CONSTRUCTORS = "## Constructors"
    const SIGNALS = "## Signals"
    const EXAMPLE = "## Example"
    const ARGUMENTS = "## Arguments"
    const METHODS = "## Methods"
    const ENUM_VALUES = "## Enum Values"
    const FIELDS = "## Public Fields"

####### types.jl

    @document SignalEmitter """
    ## SignalEmitter
    
    Object that can emit signals. All signal emitters are managed externally, they will stay allocated
    until their internal reference count reaches 0. This means whether an objects finalizer will be called
    is independent of whether the Julia-side object stays in memory or not.
    """

    @document Widget """
    ## Widget <: SignalEmitter  

    Object that can be rendered on screen. All widgets share a number of signals:

    $SIGNALS
    $(generate_signal_table(:T, 
        :realize, 
        :unrealize, 
        :destroy, 
        :hide, 
        :show, 
        :map, 
        :unmap
    ))

    Where `T` is the type subtyping `Widget`. 

    $EXAMPLE
    ```julia
    label = Label("Labels are Widgets")
    connect_signal_realize!(label) do x::Label
        println("Label was realized")
    end
    ```
    """

    @document EventController """
    ## EventController <: SignalEmitter

    Supertype of all event controllers. 
    """

####### log.jl

    @document LogDomain """
    Identifier of a log domain. Should only contain roman letters, numbers, `.`, `_` and/or `-`

    $EXAMPLE
    ```julia
    const FOO_DOMAIN = "foo-application"
    @log_info FOO_DOMAIN "Log domain succesfully assigned"
    ```
    """

    @document log_debug """
    ```
    @log_debug(::LogDomain, ::String)
    ```

    Send a message with log-level "debug". Debug message will not be 
    shown unless `set_surpress_debug` for the given log domain was set to `false`
    """

    @document log_info """
    ```
    @log_info(::LogDomain, ::String)
    ```

    Send a message with log-level "info". Info message will not be 
    shown unless `set_surpress_info` for the given log domain was set to `false`
    """

    @document log_warning """
    ```
    @log_warning(::LogDomain, ::String)
    ```

    Send a message with log-level "warning". Warnings should be reserved to situations that cannot 
    cause crahes or undefined behavior, but are still severe enough that the user needs to be notified.
    """

    @document log_critical """
    ```
    @log_critical(::LogDomain, ::String)
    ```

    Send a message with log-level "critical". Critical messages should be reserved to severe issues that 
    would usually cause undefined behavior, but where prevented from doing so by the developer. Critical 
    situations should be incapable of ending runtime in any way.
    """

    @document log_fatal """
    ```
    @log_fatal(::LogDomain, ::String)
    ```

    Send a message with log-level "fatal" and **immediately end runtime**. This should only be used if 
    an unrecoverable and severe error occurred.
    """

    @document set_surpress_debug """
    ```
    set_surpress_debug(::LogDomain:, ::Bool) -> Cvoid
    ```

    If `true`, allow printing of log messages with level "debug" for the given log domain. Defaults to `false`.
    """

    @document get_surpress_debug """
    ```
    get_surpress_debug(::LogDomain) -> Bool
    ```

    Get whether log message with level "debug" are surpressed for the given log domain.
    """

    @document set_surpress_info """
    ```
    set_surpress_info(::LogDomain:, ::Bool) -> Cvoid
    ```

    If `true`, allow printing of log messages with level "info" for the given log domain. Defaults to `false`.
    """

    @document get_surpress_info """
    ```
    get_surpress_info(::LogDomain) -> Bool
    ```

    Get whether log message with level "info" are surpressed for the given log domain.
    """

    @document set_log_file """
    ```
    set_log_file(path::String) -> Bool
    ```

    Set file to which all log message should be forward to. If the file does not yet exist, it is created. If it does exist, 
    log message are appended, no previous information will be overwritten.

    Return `true` if the file was succesfully opened, `false` otherwise
    """

###### vector.jl

    @document Vector2 """
    ## Vector2{T <: Number}

    2-dimensional vector

    $CONSTRUCTORS
    + `Vector2{T}(x::T, y::T)`
    + `Vector2{T}(all::T)`

    $FIELDS
    + `x::T`
    + `y::T`
    """

    @document Vector3 """
    ## Vector3{T <: Number}

    3-dimensional vector

    $CONSTRUCTORS
    + `Vector3{T}(x::T, y::T, z::T)`
    + `Vector3{T}(all::T)`

    $FIELDS
    + `x::T`
    + `y::T`
    + `z::T`
    """

    @document Vector4 """
    ## Vector4{T <: Number}

    4-dimensional vector

    $CONSTRUCTORS
    + `Vector4{T}(x::T, y::T, z::T, w::T)`
    + `Vector4{T}(all::T)`

    $FIELDS
    + `x::T`
    + `y::T`
    + `z::T`
    + `w::T`
    """

####### geometry.jl

    @document AxisAlignedRectangle """
    ## AxisAlignedRectangle

    Axis-aligned rectangle, defined by a top-left point and its width and height.

    $FIELDS
    + `top_left::Vector2f`
    + `size::Vector2f`

    $CONSTRUCTORS
    `AxisAlignedRectangle(top_left::Vector2f, size::Vector2f)`
    """

####### time.jl

    @document Time """
    ## Time

    Duration of time, nanosecond precision.

    $FIELDS
    (no public fields)

    $CONSTRUCTORS
    (no public constructors)
    """

    @document minutes """
    ```
    minutes(::AbstracFloat) -> Time
    ```

    Construct time as number of minutes.
    """

    @document seconds """
    ```
    seconds(::AbstracFloat) -> Time
    ```

    Construct time as number of seconds.
    """

    @document milliseconds """
    ```
    milliseconds(::AbstracFloat) -> Time
    ```

    Construct time as number of milliseconds.
    """

    @document microseconds """
    ```
    microseconds(::AbstracFloat) -> Time
    ```

    Construct time as number of microseconds.
    """

    @document nanoseconds """
    ```
    nanoseconds(::Int64) -> Time
    ```

    Construct time as number of nanoseconds.
    """

    @document as_seconds """
    ```
    as_seconds(::Time) -> Float64
    ```

    Convert time to number of seconds.
    """

    @document as_milliseconds """
    ```
    as_milliseconds(::Time) -> Float64
    ```

    Convert time to number of milliseconds.
    """

    @document as_microseconds """
    ```
    as_microseconds(::Time) -> Float64
    ```

    Convert time to number of microseconds.
    """

    @document as_nanoseconds """
    ```
    as_nanoseconds(::Time) -> Int64
    ```

    Convert time to number of nanoseconds.
    """

    @document Clock """
    ## Clock

    Object able to measure time, nanosecond-precision.

    $CONSTRUCTORS
    `Clock()`
    """

    @document restart! """
    ```
    restart!(::Clock) -> Time
    ```

    Return currently elapsed time, then restart the clock.
    """

    @document elapsed! """
    ```
    elapsed(::Clock) -> Time
    ```

    Get currently elapsed time.
    """

####### angle.jl

    @document Angle """
    ## Angle

    Object measuring an angle, unit-agnostic.

    $CONSTRUCTORS
    (no public consturctors)

    $FIELDS
    (no public fields)
    """

    @document degrees """
    ```
    degrees(::Number) -> Angle
    ```

    Get angle as number of degrees. Automatically clamped to [0°, 360°]
    """

    @document radians """
    ```
    radians(::Number) -> Angle
    ```

    Get angle as number of radians
    """

    @document as_degrees """
    ```
    as_degrees(::Angle) -> Float64
    ```

    Convert angle to degrees
    """

    @document as_radians """
    ```
    as_radians(::Angle) -> Float64
    ```

    Convert angle to radians
    """

####### application.jl

    @document Application """
    ## Application <: SignalEmitter

    Maintains a global state of all application-related objects and information.
    Signal `activate` is emitted once the application has initialized the environment,
    no mousetrap function should be called before this signal is emitted.

    $CONSTRUCTORS
    + `Application(valid_signal_id::String)``

    $SIGNALS
    $(generate_signal_table(:Application, 
        :activate, 
        :shutdown
    ))

    $EXAMPLE
    ```julia
    app = Application(\"example.app\")

    connect_signal_activate!(app) do x::Application
        # initialization here
    end

    # start the application
    run(app);
    ```
    """

    @document run! """
    ```
    run!(::Application) -> Cint
    ```

    Request application to initialize and start the main render loop
    """

    @document quit! """
    ```
    quit!(::Application) -> Cvoid
    ```

    Request application to quit immediately
    """

    @document hold! """
    ```
    hold!(::Application) -> Cvoid
    ```

    Mark the application as held. A held application cannot exit until `release!` is called
    """

    @document release! """
    ```
    release!(::Application) -> Cvoid
    ```
    
    Release a held application. If `hold!` was not called previously, this function does nothing
    """

    @document mark_as_busy! """
    ```
    mark_as_busy!(::Application) -> Cvoid
    ```

    Signal to the users operating system that the application is currently busy. All windows 
    of a busy application are marked as non-interactable until `unmark_as_busy!` is called.
    """

    @document unmark_as_busy! """
    ```
    unmark_as_busy(::Application) -> Cvoid
    ```

    No longer designate application as busy. If `mark_as_busy!` was not called previously, 
    this function does nothing.
    """

    @document get_id """
    ``` 
    get_id(::Application) -> String
    get_id(::Action) -> String
    ```

    Access ID of an `Application` or `Action`
    """

    @document add_action! """
    ```
    add_action!(::Application, ::Action) -> Cvoid
    ```

    Register an action with the application. This is usually done automaticall during `Action::set_function!`.
    """

    @document get_action """
    ```
    get_action(::Application, action_id::String) -> Action
    ```
    
    Access a registered action by its ID.
    """

    @document remove_action! """
    ```
    remove_action!(::Application, action_id::String) -> Cvoid
    ```

    Unregister an action so it is no longer available, this may cause the actions finalizer to be called.
    """
    
    @document has_action """
    ```
    has_action(::Application, action_id::String) -> Bool
    ```

    Check whether an action with the given ID was registered.
    """

    @document main """
    ```
    main(f; [application_id::String]) -> Int64
    ```

    Register a function to be called as the main loop. This will automatically create an application, 
    call the given function when it is initialized, then start the main render loop.

    $ARGUMENTS
    + `f`: Object invocable as function with signature `(::Application) -> Cvoid`
    + `application_id`: ID of the application

    $EXAMPLE
    ```julia
    mousetrap.main(; application_id = "example.app") do app::Application
        window = Window(app)

        # setup app and widgets here

        present!(window)
    end
    ```
    """

####### window.jl

    @document Window """
    ## Window <: Widget

    Top-level window, has exactly one child.

    $CONSTRUCTORS
    + `Window(::Application)`

    $SIGNALS
    $(generate_signal_table(:Window,
        :close_request, 
        :activate_default_widget, 
        :activate_focused_widget, 
        #widget_signals...
    ))

    $EXAMPLE
    ```julia
    window = Window(app)
    set_child!(window, Label("Hello Window"))
    present!(window)
    ```
    """

    @document WindowCloseRequestResult """
    
    Return type of signal `close_request` of `Window`

    $ENUM_VALUES
    + `WINDOW_CLOSE_REQUEST_RESULT_ALLOW_CLOSE`
    + `WINDOW_CLOSE_REQUEST_RESULT_PREVENT_CLOSE`
    """

    @document WINDOW_CLOSE_REQUEST_RESULT_ALLOW_CLOSE """
    Permit the window hander to close the window.
    """
    
    @document WINDOW_CLOSE_REQUEST_RESULT_PREVENT_CLOSE """
    Prevent closing of the window.
    """

    @document set_application! """
    ```
    set_application!(::Window, ::Application) -> Cvoid
    ```

    Link a window to an application, this is usually done automatically
    """

    @document set_fullscreen! """
    ```
    set_fullscreen!(::Window) -> Cvoid
    ```

    Request for the users window manager to make the window enter fullscreen mode
    """

    @document present! """
    ```
    present!(::Window) -> Cvoid
    ```

    Request for the window to realize and be shown to the user
    """

    @document set_hide_on_close! """
    ```
    set_hide_on_close!(::Window, ::Bool) -> Cvoid
    ```
    
    If `true``, window will hide when it is closed in anyway. If `false`, the windows finalizer will be called instead.
    """

    @document close! """
    ```
    close!(::Window) -> Cvoid
    ```

    Request for the window to close.
    """

    @document set_child!(::Window, ::Widget) """
    ```
    set_child!(::Window, ::Widget) -> Cvoid
    ```

    Set the singular child of the window.
    """

    @document remove_child!(::Window) """
    ```
    remove_child!(::Window, ::Widget) -> Cvoid
    ```

    Remove the singular child of the window.
    """

    @document set_transient_for! """
    ```
    set_transient_for!(self::Window, parent::Window) -> Cvoid
    ```

    Choose another window as the transient parent of this window.
    """

    @document set_destroy_with_parent! """
    ```
    set_destroy_with_parent!(::Window, ::Bool) -> Cvoid
    ```

    If `true` and this window is transient for another window, if the other windows finalizer is called, this window will also finalize.
    """

    @document get_destroy_with_parent """
    ```
    get_destroy_with_parent(::Window, ::Bool) -> Bool
    ```

    Get whether the windows finalizer should be called when its transient parent finalizes.
    """ 

    @document set_title! """
    ```
    set_title!(::Window, ::String) -> Cvoid
    ```

    Set the windows title, if the window has a custom headerbar widget set via `Windo::set_titlebar_widget!`, that widgets title will be use instead.
    """

    @document get_title """
    ```
    get_title(::Window) -> String
    ```

    Get the title used by windows titlebar 
    """

    @document set_titlebar_widget! """
    ```
    set_titlebar_widget(::Window, ::Widget) -> Cvoid
    ```

    Choose the widget user by the window as a titlebar. This will usually be a `HeaderBar`.
    """

    @document remove_titlebar_widget! """
    ```
    remove_titlebar_widget!(::Window) -> Cvoid
    ```

    Reset the windows titlebar widget, such that the default titlebar layout will be used again.
    """

    @document set_is_modal! """
    ```
    set_is_modal(::Window, ::Bool) -> Cvoid
    ```

    Set whether the window should pause its parent window while it is shown.
    """

    @document get_is_modal """
    ```
    get_is_modal(::Window) -> Bool
    ```

    Get whether the window should pause its parent window while it is shown.
    """

    @document set_is_decorated! """
    ```
    set_is_decorated(::Window, ::Bool) -> Cvoid
    ```

    If `false`, the windows titlebar will be hidden. If `true, the windows titlebar along with its titlebar widget will be visible.`
    """

    @document set_has_close_button! """
    ```
    set_has_close_button(::Window, ::Bool) -> Cvoid
    ```

    Set whether the `X` button allowing the user to close a window is visible.
    """

    @document get_has_close_button """
    ```
    get_has_close_button(::Window) -> Bool
    ```

    Get whether the windows close button is visible.
    """

    @document set_startup_notification! """
    ```
    set_startup_notification!(::Window, ::String) -> Cvoid
    ```

    Set the startup notification id that will be displayed when the window is shown for the first time. 
    There is no guarantee that this notification will be respected and presented to the user by the users operating system.
    """

    @document set_focus_visible! """
    ```
    set_focus_visible!(::Window, ::Bool) -> Cvoid
    ```

    If `true`, the currently focused widget will be highlighted, usually using a faint border around the widgets allocated area.
    """

    @document get_focus_visible """
    ```
    get_focus_visible(::Window) -> Bool
    ```

    Get whether the currently focused widget will be highlighted.
    """

    @document set_default_widget! """
    ```
    set_default_widget!(::Window, widget::Widget) -> Cvoid
    ```

    Designate a widget that is a direct or indirect child of the window as the default widget. 
    If the user activates the window, this widget will be activated and `activate_default_widget` will be emitted
    """

####### action.jl

    @document Action """
    ## Action <: SignalEmitter

    Object representing a globally registered function. Actions can be bound to `Button` or `MenuModel`
    in order for these objects to trigger behavior. The lifetime of an action is managed automatically,
    all actions are registered with their application and can be retrieved at any point.

    An action for whom `set_function!` was called is considered *stateless*, its function has the 
    signature `(::Action, [::Data_t]) -> Cvoid`.

    An action for whom `set_stateful_function!` was called is considered *stateful*. It maintains an internal
    boolean variable, the signature of its function is `(::Action, ::Bool, [::Data_t]) -> Bool`.

    If an action is stateful, a `MenuModel` menu item linked to it will appear as a check button that automatically 
    switches the actions state.

    $CONSTRUCTORS
    + `Action(it::String, ::Application)`

    $SIGNALS
    $(generate_signal_table(:Action, 
        :activated 
    ))

    $EXAMPLE
    ```julia
    action = Action("example.action", app)
    set_function!(action) do x::Action
        println("action triggered")
    end

    activate(action)
    ```
    ```
    action triggered
    ```
    """

    @document get_id(::Action) """
    ```
    get_id(::Action) -> String
    ```

    Retrieve the ID of an action.
    """

    @document activate """
    ```
    activate(::Action) -> Cvoid
    ```

    Manually trigger the actions function, this will also emit signal `activated`
    """

    @document add_shortcut! """
    ```
    add_shortcut!(::Action, ::ShotcutTrigger) -> Cvoid
    ```

    Add a shortcut trigger to the action. Shortcut triggers follow the syntax outlined in the chapter on event handling.
    """

    @document get_shortcuts """
    ```
    get_shortcuts(::Action) -> Vector{ShortcutTrigger}
    ```

    Access all registered shortcut triggers. The return vector may be empty.
    """

    @document clear_shortcuts! """
    ```
    clear_shortcuts!(::Action) -> Cvoid
    ```

    Clear all registered shortcut triggers.
    """

    @document set_enabled! """
    ```
    set_enabled!(::Action, ::Bool) -> Cvoid
    ```

    Set whether the action is enabled. A disabled action cannot be activated and all objects linked, such as `Button`s or `MenuModel`s will be disabled.
    """

    @document get_enabled """
    ```
    get_enabled(::Action) -> Bool
    ```

    Get whether the action is enabled
    """

    @document set_function! """
    ```
    set_function!(f, ::Action, [::Data_t]) -> Cvoid
    ```

    Register a function. After this call, the action is considered *stateless*.

    $ARGUMENTS
    + `f`: object invocable as function with signature `(::Action, [::Data_t]) -> Cvoid`
    + `action`: action to be modified

    $EXAMPLE
    ```julia
    action = Action("example.action", app)
    set_function!(action) do x::Action
        println("stateless action triggered")
    end
    ```
    """

    @document set_stateful_function! """
    ```
    set_stateful_function!(f, ::Action, [::Data_t]) -> Cvoid
    ```

    Register a function. After this call, the action is considered *stateful*.

    $ARGUMENTS
    + `f`: object invocable as function with signature `(::Action, ::Bool, [::Data_t]) -> Bool`
    + `action`: action to be modified

    $EXAMPLE
    ```julia
    action = Action("example.action", app)
    set_stateful_function!(action) do x::Action, current_state::Bool
        println("stateful action triggered")
        next_state = !current_state
        return next_state
    end
    ```
    """

    @document get_is_stateful """
    ```
    get_is_stateful(::Action) -> Bool
    ```

    Returns `true` if `set_stateful_function!` was called to set the actions behavior, returns `false`` otherwise.
    """ 

    @document set_state!(::Action, ::Bool) """
    ```
    set_state!(::Action, state::Bool) -> Cvoid
    ```

    If the action is stateful , set its internal state.
    """

    @document get_state(::Action) """
    ```
    get_state(::Action) -> Bool
    ```

    If the action is stateful, return its internal state, otherwise return `false`
    """

####### adjustment.jl

    @document Adjustment """
    ## Adjustment <: SignalEmitter

    Object representing a range of numbers. If a widget has an underlying `Adjustment`,
    if the widgets value changes, the adjustments values changes, and vice-versa. We can 
    therefore modify or monitor a widgets value by modifying or monitoring the underlying adjustment.

    $CONSTRUCTORS
    `Adjustment(value::Number, lower::Number, upper::Number, step_increment::Number)`

    $SIGNALS
    $(generate_signal_table(:Adjustment, 
        :value_changed,
        :properties_changed
    ))

    $EXAMPLE
    ```julia
    widget = SpinButton(0, 1, 0.01)
    range = get_adjustment(widget)
    connect_signal_value_changed!(range) do x::Adjustment
        println("SpinButton value is now: ", get_value(x))
    end
    ```
    """

    @document get_lower """
    ```
    get_lower(::Adjustment) -> Float32
    ```

    Get the lower bound of the represented range.
    """

    @document set_lower! """
    ```
    set_lower(::Adjustment, ::Number) -> Cvoid
    ```

    Set the lower bound of the represented range.
    """

    @document get_upper """
    ```
    get_upper(::Adjustment) -> Float32
    ```

    Get the upper bound of the represented range.
    """

    @document set_upper! """
    ```
    set_upper(::Adjustment, ::Number) -> Cvoid
    ```

    Set the upper bound of the represented range.
    """

    @document get_value """
    ```
    get_value(::Adjustment) -> Float32
    ```

    Get the currently selected value of the range.
    """

    @document set_value """
    ```
    set_value(::Adjustment, ::Number) -> Cvoid
    ```

    Set the currently selected value of the range
    """

    @document get_increment """
    ```
    get_increment(::Adjustment) -> Float32
    ```

    Get the step increment of the range.
    """

    @document set_increment """
    ```
    set_increment(::Adjustment, ::Number) -> Cvoid
    ```

    Set the step increment of the range 
    """

####### alignment.jl

    @document Alignment """
    
    Alignment of a widget along the horizontal or vertical axis.

    $ENUM_VALUES
    + `ALIGNMENT_START`
    + `ALIGNMENT_CENTER`
    + `ALIGNMENT_END`
    """

    @document ALIGNMENT_START """
    If horizontal, widget is aligned left, if vertical, widget is aligned top.
    """

    @document ALIGNMENT_END """
    If horizontal, widget is aligned right, if vertical, widget is aligned bottom.
    """

    @document ALIGNMENT_CENTER """
    Widget is aligned center, regardless of orientation.
    """

####### orientation.jl

    @document Orientation """

    Orientation of a widget

    $ENUM_VALUES
    + `ORIENTATION_HORIZONTAL`
    + `ORIENTATION_VERTICAL`
    """

    @document ORIENTATION_HORIZONTAL """
    Widget is aligned along the x-axis.
    """

    @document ORIENTATION_VERTICAL """
    Widget is aligned along the y-axis.
    """

####### cursor_type.jl

    @document CursorType """

    Determines shape of the cursor while it is within the corresponding widgets allocated area.

    $ENUM_VALUES
    + `CURSOR_TYPE_NONE`
    + `CURSOR_TYPE_DEFAULT`
    + `CURSOR_TYPE_HELP`
    + `CURSOR_TYPE_POINTER`
    + `CURSOR_TYPE_CONTEXT_MENU`
    + `CURSOR_TYPE_PROGRESS`
    + `CURSOR_TYPE_WAIT`
    + `CURSOR_TYPE_CELL`
    + `CURSOR_TYPE_CROSSHAIR`
    + `CURSOR_TYPE_TEXT`
    + `CURSOR_TYPE_MOVE`
    + `CURSOR_TYPE_NOT_ALLOWED`
    + `CURSOR_TYPE_GRAB`
    + `CURSOR_TYPE_GRABBING`
    + `CURSOR_TYPE_ALL_SCROLL`
    + `CURSOR_TYPE_ZOOM_IN`
    + `CURSOR_TYPE_ZOOM_OUT`
    + `CURSOR_TYPE_COLUMN_RESIZE`
    + `CURSOR_TYPE_ROW_RESIZE`
    + `CURSOR_TYPE_NORTH_RESIZE`
    + `CURSOR_TYPE_NORTH_EAST_RESIZE`
    + `CURSOR_TYPE_EAST_RESIZE`
    + `CURSOR_TYPE_SOUTH_EAST_RESIZE`
    + `CURSOR_TYPE_SOUTH_RESIZE`
    + `CURSOR_TYPE_SOUTH_WEST_RESIZE`
    + `CURSOR_TYPE_WEST_RESIZE`
    + `CURSOR_TYPE_NORTH_WEST_RESIZE`
    """

    @document CURSOR_TYPE_NONE """
    No visible cursor.
    """

    @document CURSOR_TYPE_DEFAULT """
    Small arrow, default cursor for most widgets.
    """

    @document CURSOR_TYPE_POINTER """
    Hand, indicates that the current widget is clickable.
    """

    @document CURSOR_TYPE_HELP """
    Questionmark, usually opens a help dialog.
    """

    @document CURSOR_TYPE_CONTEXT_MENU """
    Pointer with `...`, informs the user that clicking will open a context menu.
    """

    @document CURSOR_TYPE_PROGRESS """
    Pointer with small "currently loading" icon.
    """

    @document CURSOR_TYPE_WAIT """
    Instructs user to wait for an action to finish.
    """

    @document CURSOR_TYPE_CELL """
    Cursor used when interacting with tables.
    """

    @document CURSOR_TYPE_CROSSHAIR """
    Crosshair-shaped cursor, used for precise selections.
    """

    @document CURSOR_TYPE_TEXT """
    Text caret.
    """

    @document CURSOR_TYPE_MOVE """
    Four-pointer arrow, indicates that the selected object can be moved freely.
    """

    @document CURSOR_TYPE_NOT_ALLOWED """
    Indicates to the user that the action is prohibited.
    """

    @document CURSOR_TYPE_GRAB """
    Open hand, not yet grabbing.
    """

    @document CURSOR_TYPE_GRABBING """
    Close hand, currently grabbing.
    """

    @document CURSOR_TYPE_ALL_SCROLL """
    Four-directional scrolling.
    """

    @document CURSOR_TYPE_ZOOM_IN """
    Lens, usually with a plus icon.
    """

    @document CURSOR_TYPE_ZOOM_OUT """
    Lens, usually with a minus icon.
    """

    @document CURSOR_TYPE_COLUMN_RESIZE """
    Left-right arrow.
    """

    @document CURSOR_TYPE_ROW_RESIZE """
    Up-down arrow.
    """

    @document CURSOR_TYPE_NORTH_RESIZE """
    Up arrow
    """

    @document CURSOR_TYPE_NORTH_EAST_RESIZE """
    Up-right arrow
    """

    @document CURSOR_TYPE_EAST_RESIZE """
    Right arrow
    """

    @document CURSOR_TYPE_SOUTH_EAST_RESIZE """
    Bottom-right arrow
    """

    @document CURSOR_TYPE_SOUTH_RESIZE """
    Down arrow
    """

    @document CURSOR_TYPE_SOUTH_WEST_RESIZE """
    Down-left arrow
    """

    @document CURSOR_TYPE_WEST_RESIZE """
    Left arrow
    """

    @document CURSOR_TYPE_NORTH_WEST_RESIZE """
    Up-left arrow
    """

####### aspect_frame.jl

    @document AspectFrame """
    ## AspectFrame <: Widget

    Container widget with a singular child. Will make sure that the size allocation of its child
    follows the given aspect ratio at all times.

    $CONSTRUCTORS
    `AspectFrame(ratio::AbstractFloat; [child_x_alignment::Abstract_float, child_y_alignment::AbstractFloat])`

    $EXAMPLE
    ```julia
    # make sure image stay square
    image = ImageDisplay()
    aspect_frame = AspectFrame(1.0)
    set_child!(aspect_frame, image)
    ````
    """

    @document set_ratio! """    
    ```
    set_ratio!(x::AspectFrame, ratio::AbstractFloat) -> Cvoid
    ```

    Set ratio of aspect frame.

    $ARGUMENTS
    + `x`: instance
    + `ratio`: Float > 0
    """

    @document get_ratio """
    ```
    get_ratio(::AspectFrame) -> Float32
    ````

    Get ratio of aspect frame.
    """

    @document set_child_x_alignment! """
    ```
    set_child_x_alignment(instance::AspectFrame, alignment::AbstractFloat) -> Cvoid
    ```

    $ARGUMENTS
    + `instance`:  aspect frame
    + `alignment`: Float in [0, 1]
    """

    @document get_child_x_alignment """
    ```
    get_child_x_alignment(::AspectFrame) -> Float32
    ```

    Access x-alignment of aspect frame child.
    """

    @document set_child_y_alignment! """
    ```
    set_child_y_alignment(instance::AspectFrame, alignment::AbstractFloat) -> Cvoid
    ```

    $ARGUMENTS
    + `instance`: aspect frame
    + `alignment`: Float in [0, 1]
    """

    @document get_child_y_alignment """
    ```
    get_child_y_alignment(::AspectFrame) -> Float32
    ```

    Access y-alignment of aspect frame child.
    """

    @document set_child! """
    ```
    set_child!(::AspectFrame, ::Widget) -> Cvoid
    ```

    Set aspect frames singular child.
    """

    @document remove_child! """
    ```
    remove_child!(::AspectFrame) -> Cvoid
    ```

    Remove aspect frames singular child.
    """

####### box.jl

    @document Box """
    Widget container that arranges its children in a row (or column, if vertically oriented).

    $CONSTRUCTORS
    ```
    Box(::Orientation)
    ```

    $EXAMPLE
    ```julia
    box = Box(ORIENTATION_HORIZONTAL)
    push_back!(box, Label("first child"))
    push_back!(box, Label("second child"))
    ```
    """

    @document push_back!(::Box, ::Widget) """
    ```
    push_back!(::Box, ::Widget) -> Cvoid
    ```

    Add widget to the end of the box.
    """

    @document push_front!(::Box, ::Widget) """
    ```
    push_front!(::Box, ::Widget) -> Cvoid
    ```

    Add widget to the start of the box.
    """

    @document insert_after! """
    ```
    insert_after!(::Box, to_append::Widget, after::Widget)
    ```

    Insert widget right after another widget that is already inside the box.
    """

    @document remove!(::Box, ::Widget) """
    ```
    remove!(::Box) -> Cvoid
    ```

    Remove a widget from the box.
    """

    @document clear!(::Box) """
    ```
    clear!(::Box) -> Cvoid
    ```

    Remove all children from box.
    """

    @document set_homogeneous! """
    ```
    set_homogeneous!(::Box, ::Bool) -> Cvoid
    ```

    If `true`, box will attempt to allocate the same amount of space for each of its children.
    """

    @document get_homogeneous """
    ```
    get_homogeneous(::Box) -> Bool
    ```

    Get whether box will attempt to allocate the same amount of space for each of its children.
    """

    @document set_spacing! """
    ```
    set_spacing!(::Box, ::Number) -> Cvoid
    ```

    Set spacing, which will insert empty space between any two pair of children inside the box.

    $ARGUMENTS
    + `::Box`: instance
    + `::Number`: spacing, floating point value > 0, in pixels
    """

    @document get_spacing """
    ```
    get_spacing(::Box) -> Float32
    ```

    Get spacing of box, or 0 if not specified.
    """

    @document set_orientation!(::Box, ::Orientation) """
    ```
    set_orientation!(::Box, ::Orientation) -> Cvoid
    ```

    Set whether box should align its children vertically or horizontally.
    """

    @document get_orientation(::Box) """
    ```
    get_orientation(::Box) -> Orientation
    ```

    Get whether the box will align its children vertically or horizontally
    """

####### button.jl

    @document Button """
    ## Button <: Widget

    Widget that, when clicked, either activates an action set via `set_action!` and/or invokes 
    the signal handler connect so signal `clicked`. Has a singular child used as its label.

    $CONSTRUCTORS
    ```
    Button()
    ```

    $SIGNALS
    $(generate_signal_table(:T, 
        :clicked,
        :activate
    ))

    $EXAMPLE
    ```julia
    button = Button
    set_child!(button, Label("Click Me"))
    connect_signal_clicked!(button) do x::Button
        println("Button Clicked")
    end
    ```
    """

    @document set_action!(::Button, ::Action) """
    ```
    set_action!(::Button, ::Action) -> Cvoid
    ```

    Link an action to a button. When the button is clicked, the action is activated. If the action 
    is disabled or otherwise made non-activatable, the button will be disabled automatically. 
    """

    @document set_has_frame!(::Button, ::Bool) """
    ```
    set_has_frame!(::Button, ::Bool) -> Cvoid
    ```

    If `false`, button will have no visual element but retains all other properties, 
    such as its allocated area and child.
    """

    @document get_has_frame(::Button) """
    ```
    get_has_frame(::Button) -> Bool
    ```

    Get whether the buttons own visual elements are displayed.
    """

    @document set_is_circular(::Button, ::Bool) """
    ```
    set_is_circular(::Button, ::Bool) -> Cvoid
    ```

    If `true`, button is displayed as a circle. If `false`, button is displayed as a rectangle.
    """

    @document get_is_circular(::Button) """
    ```
    get_is_circular(::Button) -> Bool
    ```

    Get whether button is displayed as a circle.
    """

    @document set_child!(::Button) """
    ```
    set_child!(::Button) -> Cvoid
    ```

    Set the buttons child.
    """

    @document remove_child!(::Button) """
    ```
    remove_child!(::Button) -> Cvoid
    ```

    Clear buttons child.
    """

####### center_box.jl

    @document CenterBox """
    ## CenterBox <: Widget

    Widget container that has exactly 3 children. They are arranged such that the center child
    stays center at all time. This is useful to enforce symmetry.

    $CONSTRUCTORS
    ```
    CenterBox(::Orientation)
    ```
    """

    @document set_start_child!(::CenterBox, ::Widget) """
    ```
    set_start_child!(::CenterBox, ::Widget) -> Cvoid
    ```

    If center box is horizontal, set left-most child, if vertical, set top-most child.
    """

    @document set_end_child!(::CenterBox, ::Widget) """
    ```
    set_end_child!(::CenterBox, ::Widget) -> Cvoid
    ```

    If center box is horizontal, set right-most child, if vertical, set bottom-most child.
    """

    @document set_center_child!(::CenterBox, ::Widget) """
    ```
    set_center_child!(::CenterBox, ::Widget) -> Cvoid
    ```

    Set middle child.
    """

    @document remove_start_child!(::CenterBox, ::Widget) """
    ```
    remove_start_child!(::CenterBox, ::Widget) -> Cvoid
    ```

    If center box is horizontal, remove left-most child, if vertical, remove top-most child.
    """

    @document remove_end_child!(::CenterBox, ::Widget) """
    ```
    remove_end_child!(::CenterBox, ::Widget) -> Cvoid
    ```

    If center box is horizontal, remove right-most child, if vertical, remove bottom-most child.
    """

    @document remove_center_child!(::CenterBox, ::Widget) """
    ```
    remove_center_child!(::CenterBox, ::Widget) -> Cvoid
    ```

    remove middle child.
    """

    @document set_orientation!(::CenterBox, ::Orientation) """
    ```
    set_orientation(::CenterBox, ::Orientation) -> Cvoid
    ```

    Set whether center box will align its children horizontally or vertically.
    """

    @document get_orientation(::CenterBox, ::Orientation) """
    ```
    get_orientation(::CenterBox) -> Orientation
    ```

    Get whether center box will align its children horizontally or vertically.
    """

####### check_button.jl

    @document CheckButton """
    ## CheckButton <: Widget

    Button that can be toggled, if toggled, it displays a checkmark.

    $CONSTRUCTORS
    ```
    CheckButton()
    ```

    $SIGNALS
    $(generate_signal_table(:CheckButton,
        :toggled,
        :activate
    ))

    $EXAMPLE
    ```julia
    button = CheckButton()
    connect_signal_toggled(button) do x::CheckButton
        println("state is now: " * string(get_is_active(x)))
    end
    ```
    """

    @document CheckButtonState """
    Internal state of `CheckButton`

    $ENUM_VALUES
    + `CHECK_BUTTON_STATE_ACTIVE`
    + `CHECK_BUTTON_STATE_INCONSISTENT`
    + `CHECK_BUTTON_STATE_INACTIVE`
    """

    @document CHECK_BUTTON_STATE_ACTIVE """
    Active, usually displayed as a check mark
    """

    @document CHECK_BUTTON_STATE_INACTIVE """
    Inactive, usually displayed with no check mark
    """

    @document CHECK_BUTTON_STATE_INCONSISTENT """
    Neither active nor inactive
    """

    @document set_state!(::CheckButton, ::CheckButtonState) """
    ```
    set_state!(::CheckButton, ::CheckButtonState) -> Cvoid
    ```

    Set internal state of the check button.
    """

    @document get_state(::CheckButton) """
    ```
    get_state(::CheckButton) -> CheckButtonState
    ```

    Get internal state of the check button.
    """

    @document get_is_active!(::CheckButton) """
    ```
    get_is_active!(::CheckButton) -> Bool
    ```

    Returns `true` if check button state is `CHECK_BUTTON_STATE_ACTIVE`, false otherwise.
    """

    if mousetrap.detail.GTK_MINOR_VERSION >= 8
        @document set_child!(::CheckButton) """
        ```
        set_child!(::CheckButton, ::Widget) -> Cvoid
        ```

        Set child of check button.

        (This function is only available with GTK4.8+)
        """

        @document remove_child!(::CheckButton) """
        ```
        remove_child!(::CheckButton) -> Cvoid
        ```

        Clear check buttons child.

        (This function is only available with GTK4.8+)
        """
    end

####### switch.jl

    @document Switch """
    ## Switch <: Widget

    Lightswitch-like widget that is either on or off.

    $CONSTRUCTORS
    ```
    Switch()
    ```

    $SIGNALS
    $(generate_signal_table(:Switch,
        :activate
    ))

    $EXAMPLE
    ```julia
    switch = Switch()
    connect_signal_activate(switch) do x::Switch
        println("state is now: " * string(get_is_active(x)))
    end
    """

    @document get_is_active(::Switch) """
    ```
    get_is_active(::Switch) -> Bool
    ```

    Get whether the switch is currently in the "on" position.
    """

    @document set_is_active!(::Switch, ::Bool) """
    ```
    set_is_active!(::Switch) -> Bool
    ```

    Set whether switch is currently in the "on" position.
    """

####### toggle_button.jl

    @document ToggleButton """
    ## ToggleButton <: Widget

    Button that stays depressed to indicate a boolean state.

    $CONSTRUCTORS
    ```
    ToggleButton()
    ```

    $SIGNALS
    $(generate_signal_table(:ToggleButton,
        :activate,
        :toggled, 
        :clicked
    ))

    $EXAMPLE
    ```julia
    toggle_button = ToggleButton()
    connect_signal_toggled(toggle_button) do x::ToggleButton
        println("state is now: " * string(get_is_active(x)))
    end
    ```
    """

    @document set_is_active!(::ToggleButton, ::Bool) """
    ```
    set_is_active!(::ToggleButton, ::Bool) -> Cvoid
    ```

    Set whether the toggle button is currently depressed.
    """

    @document get_is_active(::ToggleButton) """
    ```
    get_is_active(::ToggleButton) -> Bool
    ```

    Get whether the toggle button is currently depressed.
    """

####### viewport.jl

    @document ScrollbarVisibilityPolicy """
    Determines if and when scroll bars of a `Viewport` are shown

    $ENUM_VALUES
    + `SCROLLBAR_VISIBILITY_POLICY_NEVER`
    + `SCROLLBAR_VISIBILITY_POLICY_ALWAYS`
    + `SCROLLBAR_VISIBILITY_POLICY_AUTOMATIC`
    """

    @document SCROLLBAR_VISIBILITY_POLICY_NEVER """
    Scrollbar is hidden at all times.
    """

    @document SCROLLBAR_VISIBILITY_POLICY_ALWAYS """
    Scrollbar is visible at all times.
    """

    @document SCROLLBAR_VISIBILIT_POLICY_AUTOMATIC """
    When the users cursor enters or exists the `Viewport`, an animation will play that reveals or hides the scrollbar
    """

    @document CornerPlacement """
    Determines location of both scrollbars of a `Viewport`

    $ENUM_VALUES
    + `CORNER_PLACEMENT_TOP_LEFT`
    + `CORNER_PLACEMENT_TOP_RIGHT`
    + `CORNER_PLACEMENT_BOTTOM_LEFT`
    + `CORNER_PLACEMENT_BOTTOM_RIGHT`
    """

    @document CORNER_PLACEMENT_TOP_LEFT """
    Horizontal scrollbar will be at the top, vertical scrollbar will be on the left.
    """

    @document CORNER_PLACEMENT_TOP_RIGHT """
    Horizontal scrollbar will be at the top, vertical scrollbar will be on the right.
    """

    @document CORNER_PLACEMENT_BOTTOM_LEFT """
    Horizontal scrollbar will be at the bottom, vertical scrollbar will be on the left.
    """

    @document CORNER_PLACEMENT_BOTTOM_RIGHT """
    Horizontal scrollbar will be at the bottom, vertical scrollbar will be on the right.
    """

    @document ScrollType """
    Determines type of scroll-action triggered by the user.

    $ENUM_VALUES
    + `SCROLL_TYPE_NONE`
    + `SCROLL_TYPE_JUMP`
    + `SCROLL_TYPE_STEP_BACKWARD`
    + `SCROLL_TYPE_STEP_FORWARD`
    + `SCROLL_TYPE_STEP_UP`
    + `SCROLL_TYPE_STEP_DOWN`
    + `SCROLL_TYPE_STEP_RIGHT`
    + `SCROLL_TYPE_STEP_LEFT`
    + `SCROLL_TYPE_PAGE_BACKWARD`
    + `SCROLL_TYPE_PAGE_FORWARD`
    + `SCROLL_TYPE_PAGE_UP`
    + `SCROLL_TYPE_PAGE_DOWN`
    + `SCROLL_TYPE_PAGE_LEFT`
    + `SCROLL_TYPE_PAGE_RIGHT`
    + `SCROLL_TYPE_SCROLL_START`
    + `SCROLL_TYPE_SCROLL_END`
    """

    @document Viewport """
    ## Viewport <: Widget

    Widget with exactly one child. The size allocation of the viewport is independent of that
    of its child. If the child allocates an area larger than that of the viewport, the child
    is clipped and only part of it is shown. The user can scroll horizontally or vertically 
    to reveal a different part of the child.

    $CONSTRUCTORS
    ```
    Viewport()
    ```

    $SIGNALS
    $(generate_signal_table(:Viewport,
        :scroll_child
    ))
    """

    @document set_propagate_natural_height! """
    ```
    set_propagate_natural_height!(::Viewport, ::Bool) -> Cvoid
    ```

    If `true`, viewport will assume the height of its child at all times.
    """

    @document get_propagate_natural_height """
    ```
    set_propagate_natural_height!(::Viewport) -> Bool
    ```

    Get whether viewport should assume height of its child.
    """

    @document set_propagate_natural_width! """
    ```
    set_propagate_natural_wdith!(::Viewport, ::Bool) -> Cvoid
    ```

    If `true`, viewport will assume the width of its child at all times.
    """

    @document get_propagate_natural_width """
    ```
    get_propagate_natural_wdith!(::Viewport) -> Bool
    ```

    Get whether viewport should assume width of its child.
    """

    @document set_horizontal_scrollbar_policy! """
    ```
    set_horizontal_scrollbar_policy(::Viewport, ::ScrollbarPolicy) -> Cvoid
    ```

    Set how the horizontal scrollbar should behave.
    """

    @document get_horizontal_scrollbar_policy """
    ```
    get_horizontal_scrollbar_policy(::Viewport) -> ScrollbarPolicy
    ```

    Get how the horizontal scrollbar behaves.
    """

    @document set_vertical_scrollbar_policy! """
    ```
    set_vertical_scrollbar_policy(::Viewport, ::ScrollbarPolicy) -> Cvoid
    ```

    Set how the vertical scrollbar should behave.
    """

    @document get_vertical_scrollbar_policy """
    ```
    get_vertical_scrollbar_policy(::Viewport) -> ScrollbarPolicy
    ```

    Get how the vertical scrollbar behaves.
    """

    @document set_scrollbar_placement """
    ```
    set_scrollbar_placement(::Viewport, ::CornerPlacement) -> Cvoid
    ```

    Set relative location of both scrollbars.
    """

    @document get_scrollbar_placement """
    ```
    get_scrollbar_placement(::Viewport) -> CornerPlacement
    ```

    Get relative location of both scrollbars.
    """

    @document set_has_frame!(::Viewport, ::Bool) """
    ```
    set_has_frame!(::Viewport, ::Bool) -> Cvoid
    ```

    Set whether the viewport should have an outline and rounded corners.
    """

    @document get_has_frame(::Viewport) """
    ```
    get_has_frame(::Viewport) -> Bool
    ```

    Get whether the viewport has an outline and rounded corners.
    """

    @document set_kinetic_scrolling_enabled! """
    ```
    set_kinetic_scrolling_enabled!(::Viewport, ::Bool) -> Cvoid
    ```

    Set whether kinetic scroll is possible when scrolling the viewport. 
    When enabled, a scroll action will not seizes once the user stops operating the scrollbars,
    instead, the child will keep scrolling as if it had "inertia". 
    """

    @document get_kinetic_scrolling_enabled """
    ```
    get_kinetic_scrolling_enabled(::Viewport) -> Bool
    ```

    Get whether kinetic scrolling is possible for this viewport.
    """

    @document get_horizontal_adjustment(::Viewport) """
    ```
    get_horizontal_adjustment(::Viewport) -> Adjustment
    ```

    Access the underling adjustment of the horizontal scrollbar.
    """

    @document get_vertical_adjustment(::Viewport) """
    ```
    get_vertical_adjustment(::Viewport) -> Adjustment
    ```

    Access the underling adjustment of the vertical scrollbar.
    """
    
    @document set_child!(::Viewport, ::Widget) """
    ```
    set_child!(::Viewport) -> Cvoid
    ```

    Set singular child of the viewport
    """

    @document remove_child!(::Viewport) """
    ```
    remove_child!(::Viewport) -> Cvoid
    ```

    Clear viewports child.
    """

####### color.jl

    @document Color """
    Color representation
    """

    @document RBGA """
    ## RGBA <: Color

    Color representation in RGBA format

    $FIELDS
    + `r`: red component, 32-bit float in [0, 1]
    + `g`: green component, 32-bit float in [0, 1]
    + `b`: blue component, 32-bit float in [0, 1]
    + `a`: opacity (alpha), 32-bit float in [0, 1]

    $CONSTRUCTORS
    ```
    RGBA(r::AbstractFloat, g::AbstractFloat, b::AbstractFloat, a::AbstractFloat)
    ```
    """

    @document HSVA """
    ## HSVA <: Color

    Color representation in HSVA format

    $FIELDS
    + `h`: hue component, 32-bit float in [0, 1]
    + `s`: saturation component, 32-bit float in [0, 1]
    + `v`: value component, 32-bit float in [0, 1]
    + `a`: opacity (alpha), 32-bit float in [0, 1]

    $CONSTRUCTORS
    ```
    HSVA(h::AbstractFloat, s::AbstractFloat, b::AbstractFloat, a::AbstractFloat)
    ```
    """

    @document rgba_to_hsva """
    ```
    rgba_to_hsva(::RGBA) -> HSVA
    ```

    Convert RGBA to HSVA
    """

    @document hsva_to_rgba """
    ```
    hsva_to_rgba(::HSVA) -> RGBA
    ```

    Convert HSVA to RGBA
    """

    @document is_valid_html_code """
    ```
    is_valid_html_code(::String) -> Bool
    ```

    Check whether identifier can be parsed with `rgba_to_html_code`.
    """

    @document rgba_to_html_code """
    ```
    rgba_to_html_code(::RGBA) -> String
    ```

    Convet RGBA to a string of the form "#RRGGBB` where each component is translated into [0, 255], 
    then converted into hexadecimal. The opacity component is ignored.

    $EXAMPLE
    ```julia
    rgba = RGBA(1, 0, 1, 0.5)
    as_html_code = rgba_to_html_code(rgba)
    println(as_html_code)
    ```
    ```
    #FF00FF
    ```
    """

    @document html_code_to_rgba(code::String) """
    ```
    html_code_to_rgba(::String) -> RGBA
    ```

    Convert html code of the form "#RRGGBB" or "#RRGGBBAA", where each component is in [0, 255], hexadecimal,  to RGBA
    $EXAMPLE
    ```julia
    code::String = #...
    if is_valid_html_code(code)
        return RBGA(html_code_to_rgba(code))
    else
        # handle error
    end
    ```
    """

####### icon.jl

    @document Icon """
    ## Icon

    Non-mutating stand-in for an icon file on disk. Interacts with `IconTheme` in 
    order to provide themed icon sets.

    $CONSTRUCTORS 
    ```
    Icon()
    ```
    """

    @document IconID """
    identifier of an icon, used to query a file from an `IconTheme`
    """

    @document IconTheme """
    ## IconTheme

    Represents an icon theme organized through the [freedesktop icon theme specification](https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html).
    Only folders which conform to this structure can be loaded.

    $CONSTRUCTORS
    ```
    IconTheme(::Window)
    ```
    """

    @document create_from_file!(::Icon, ::String) """
    ```
    create_from_file!(::Icon, path::String) -> Bool
    ```

    Load an icon from an image or vector graphics file. Returns `true` if operation was succesfull.

    ## Supported File Formats:
    | Format Name             | File Extensions |
    |-------------------------|-----------------|
    | PNG                     | `.png`  |
    | JPEG                    | `.jpeg` `.jpe` `.jpg`  |
    | JPEG XL image           | `.jxl`  |
    | Windows Metafile        | `.wmf` `.apm`  |
    | Windows animated cursor | `.ani`  |
    | BMP                     | `.bmp`  |
    | GIF                     | `.gif`  |
    | MacOS X icon            | `.icns`  |
    | Windows icon            | `.ico` `.cur`  |
    | PNM/PBM/PGM/PPM         | `.pnm` `.pbm` `.pgm` `.ppm`  |
    | QuickTime               | `.qtif` `.qif`  |
    | Scalable Vector Graphics | `.svg` `.svgz` `.svg.gz`  |
    | Targa                   | `.tga` `.targa`  |
    | TIFF                    | `.tiff` `.tif`  |
    | WebP                    | `.webp`  |
    | XBM                     | `.xbm`  |
    | XPM                     | `.xpm`  |
    """

    @document create_from_theme """
    ```
    create_from_theme(::Icon, ::IconTheme, ::IconID, square_resoution::Integer, [scale::Integer]) -> Bool
    ```
    
    Load an icon from a theme and icon id. Returns `true` if operation was succesfull.

    $ARGUMENTS
    + `::Icon`: icon to initialize
    + `::IconTheme`: theme to query
    + `::IconID`: id of the icon
    + `square_resolution`: Resolution the icon should be loaded at, for example 32 will load the item as a 32x32px image. 
    + `scale`: multiplier for square_resolution, can be used to enable global scaling of icons for people with visual impairment
    """

    @document get_name(::Icon) """
    ```
    get_name(::Icon) -> IconID
    ```

    Get ID of icon.
    """

    @document get_size(::Icon) """
    ```
    get_size(::Icon) -> Vector2i
    ```

    Get allocated resolution of icon.
    """

    @document has_icon """
    ```
    has_icon(::IconTheme, ::IconID) -> Bool
    has_icon(::IconTheme, ::Icon) -> Bool
    ```
    
    Check if icon is available in theme.
    """

    @document add_resource_path!(::IconTheme, ::String) """
    ```
    add_resource_path!(::IconTheme, path::String) -> Cvoid
    ```

    Add resource path to the list of resource pathes that an icon theme will query for icons. The assigned
    folder has to conform to the [freedesktop icon theme specification](https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html) 
    in order for it to be able to be queried.
    """

    @document set_resource_path!(::IconTheme, ::String) """
    ```
    set_resource_path!(::IconTheme, path::String) -> Cvoid
    ```

    Override the resource path that an icon theme will query for icons. The assigned
    folder has to conform to the [freedesktop icon theme specification](https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html) 
    in order for it to be able to be queried.
    """

    @document get_icon_names """
    ```
    get_icon_names(::IconTheme) -> Vector{String}
    ```

    Get list of icon ids available in the theme. This will usually include system-wide installed icon themes.
    """

####### image.jl

        @document InterpolationType """
        Algorithm choice for scaling `Image`

        $ENUM_VALUES
        + `INTERPOLATION_TYPE_NEAREST`
        + `INTERPOLATION_TYPE_TILES`
        + `INTERPOLATION_TYPE_BILINEAR`
        + `INTERPOLATION_TYPE_HYPERBOLIC`
        """


        @document INTERPOLATION_TYPE_NEAREST """
        Nearest-neighbor scaling
        """

        @document INTERPOLATION_TYPE_TILES """
        Nearest-neighbor when upscaling, linear inteprolation when downscaling
        """

        @document INTERPOLATION_BILINEAR """
        linear filtering
        """

        @document INTERPOLATION_HYPERBOLIC """
        cubic filtering
        """

        @document Image """
        2D Image data, stored as RGBA8888

        $CONSTRUCTORS
        ```
        Image()
        Image(path::String)
        Image(width::Integer, height::Integer, [color::RGBA])
        ```
        """

        @document create!(::Image, ::Integer, ::Integer, ::RGBA) """
        ```
        create!(::Image, width::Integer, height::Integer, [default_color::RGBA]) -> Cvoid
        ```

        Initialize the image at given size, each pixel is so to given color.
        """

        @document create_from_file!(image::Image, path::String) """
        ```
        create_from_file!(::Image, path::String) -> Bool
        ```

        Create image from file. Supper formats include:

        Supported File Formats include but are not limited to:

        | Format Name             | File Extensions |
        |-------------------------|-----------------|
        | PNG                     | `.png`  |
        | JPEG                    | `.jpeg` `.jpe` `.jpg`  |
        | JPEG XL image           | `.jxl`  |
        | BMP                     | `.bmp`  |
        | GIF                     | `.gif`  |
        """

        @document save_to_file!(::Image, ::String) """
        ```
        save_to_file!(::Image, path::String) -> Bool
        ```

        Store image to file, file format is determined based on the file extension supplied with the given path.
        """

        @document get_size(::Image) """
        ```
        get_size(::Image) -> Vecto2i
        ```

        Get image resolution
        """

        @document get_n_pixels """
        ```
        get_n_pixels(::Image) -> Int64
        ```
        Returns width * height
        """ 

        @document as_scaled """
        ```
        as_scaled(::Image, new_width::Integer, new_height::Integer, [::Interpolation]) -> Image
        ```

        Create scaled version from given image, similar to the "scale canvas" option in many image editing software. The original image is not mutated.
        """

        @document as_cropped """
        ```
        as_cropped(::Image, offset_x::Signed, offset_y::Signed, new_width::Integer, new_height::Integer) -> Image
        ```

        Create cropped version from given image, similar to the "resize canvas" option in many image editing software. 
        The original image it not mutated. Any additional area outside the data of the original image will be filled with `RGBA(0, 0, 0, 0)`
        
        $ARGUMENTS
        + `::Image`: source image, will not be modified
        + `offset_x`: top-left-most pixels x coordinates, may be negative
        + `offset_y`: top-left-most pixels y coordinates, may be negative
        + `new_width`: width of the resulting image, > 1
        + `new_width`: height of the resulting image, > 1
        """

        @document set_pixel! """
        ```
        set_pixel!(::Image, x::Integer, y::Integer, color::Color) -> Cvoid
        ```

        Set pixel of image, 1-based indexing.
        """

        @document get_pixel """
        ```
        get_pixel(::Image, x::Ineger, y::Integer) -> RGBA
        ```

        Get pixel of image, 1-based indexing.
        """

    ####### key_file.jl

        @document KeyFile """
        ## KeyFile <: SignalEmitter

        File type supporting serialization and deserialization of most C-types. Useful 
        for storing custom information in a human-readable, human-editable way.

        $CONSTRUCTORS
        ```
        KeyFile()
        KeyFile(path::String)
        ```
        """

        @document GroupID """
        ID of a `KeyFile` group. Allows roman letters, '_' and '.'
        """

        @document KeyID """
        ID of a `KeyFile` key-value pair. Allows roman letters and '_'
        """

        @document as_string """
        ```
        as_string(::KeyFile) -> String
        ```

        Serialize entire file into a string.
        """

        @document create_from_file!(::KeyFile, ::String) """
        ```
        create_from_file!(::KeyFile, path::String) -> Bool
        ```

        Load from file. If parsing is unsucceful, prints a soft warning and returns `false`
        """

        @document create_from_string!(::KeyFile, ::String) """
        ```
        create_from_string!(::KeyFile, serialized_file::String) -> Bool
        ```

        Deserialize from string. If parsing is unsuccesful, prints a soft warning and returns `false`
        """

        @document save_to_file(::KeyFile, ::String) """
        ```
        save_to_file(::KeyFile, path::String) -> Bool
        ```

        Write key file to path. Returns `true` if succesfull, false otherwise.
        """

        @document get_groups """
        ```
        get_groups(::KeyFile) -> Vector{GroupID}
        ```

        Get IDs of all groups in file.
        """

        @document get_keys """
        ```
        get_keys(::KeyFile, ::GroupID) -> Vector{KeyID}
        ```

        Get IDs of all keys in group.
        """

        @document has_group """
        ```
        has_group(::KeyFile, ::GroupID) -> Bool
        ```
        Get whether a group with given ID exists in file.
        """

        @document has_key """
        ```
        has_key(::KeyFile, ::GroupID, ::KeyID) -> Bool
        ```
        Get whether a key with given ID exists in group.
        """

        @document set_comment_above_group! """
        ```
        set_comment_above_group(::KeyFile, ::GroupID, comment::String) -> Cvoid
        ```

        Overwrite comment above group declaration.
        """

        @document set_comment_above_key! """
        ```
        set_comment_above_key!(::KeFile, ::GroupID, ::KeyID, comment::String) -> Cvoid
        ```

        Overwrite comment above key-value pair in group.
        """
        @document get_comment_above_group """
        ```
        get_comment_above_group(::KeyFile, ::GroupID) -> String
        ```

        Get singular comment above group in file.
        """

        @document todo """
        ```
        get_comment_above_key!(::KeyFile, ::GroupID, ::KeyID) -> String
        ```

        Get comment above key in group.
        """

        @document set_value!(::KeyFile, ::GroupID, ::KeyID, ::Any) """
        ```
        set_value!(::KeyFile, ::GroupID, ::KeyID, ::Bool) -> Cvoid
        set_value!(::KeyFile, ::GroupID, ::KeyID, ::Vector{Bool}) -> Cvoid
        set_value!(::KeyFile, ::GroupID, ::KeyID, ::AbstractFloat) -> Cvoid
        set_value!(::KeyFile, ::GroupID, ::KeyID, ::Vector{<: AbstractFloat}) -> Cvoid
        set_value!(::KeyFile, ::GroupID, ::KeyID, ::Signed) -> Cvoid
        set_value!(::KeyFile, ::GroupID, ::KeyID, ::Vector{Signed}) -> Cvoid
        set_value!(::KeyFile, ::GroupID, ::KeyID, ::Unsigned) -> Cvoid
        set_value!(::KeyFile, ::GroupID, ::KeyID, ::Vector{Unsigned}) -> Cvoid
        set_value!(::KeyFile, ::GroupID, ::KeyID, ::String) -> Cvoid
        set_value!(::KeyFile, ::GroupID, ::KeyID, ::Vector{String}) -> Cvoid
        set_value!(::KeyFile, ::GroupID, ::KeyID, ::Image) -> Cvoid
        set_value!(::KeyFile, ::GroupID, ::KeyID, ::RGBA) -> Cvoid
        set_value!(::KeyFile, ::GroupID, ::KeyID, ::HSVA) -> Cvoid
        ```

        Serialize value and store at given key in given group. If key or group does not yet exist, it is created.
        """

        @document get_value(::KeyFile, ::GroupID, ::KeyID, ::Type) """
        ```
        get_value(::KeyFile, ::GroupID, ::KeyID, ::Type{Bool}) -> Bool
        get_value(::KeyFile, ::GroupID, ::KeyID, ::Type{Vector{Bool}}) -> Vector{Bool}
        get_value(::KeyFile, ::GroupID, ::KeyID, ::Type{AbstractFloat}) -> AbstractFloat
        get_value(::KeyFile, ::GroupID, ::KeyID, ::Type{Vector{<:AbstractFloat}}) -> Vector{<:AbstractFloat}
        get_value(::KeyFile, ::GroupID, ::KeyID, ::Type{Signed}) -> Signed
        get_value(::KeyFile, ::GroupID, ::KeyID, ::Type{Vector{<:Signed}}) -> Vector{<:Signed}
        get_value(::KeyFile, ::GroupID, ::KeyID, ::Type{Unsigned}) -> Unsigned
        get_value(::KeyFile, ::GroupID, ::KeyID, ::Type{Vector{<:Unsigned}}) -> Vector{<:Unsigned}
        get_value(::KeyFile, ::GroupID, ::KeyID, ::Type{String}) -> String
        get_value(::KeyFile, ::GroupID, ::KeyID, ::Type{Vector{String}}) -> Vector{String}
        get_value(::KeyFile, ::GroupID, ::KeyID, ::Type{RGBA}) -> RGBA
        get_value(::KeyFile, ::GroupID, ::KeyID, ::Type{HSVA}) -> HSVA
        get_value(::KeyFile, ::GroupID, ::KeyID, ::Type{Image}) -> Image
        ```
        
        Deserialize value from file. If they key does not exist, a soft warning is printed.

        $EXAMPLE
        ```julia
        # access RGBA stored in file
        file = KeyFile()
        create_from_file!(file, #...
        color = get_value(file, "example_group", "example_key", RGBA)
    
        """

####### file_descriptor.jl

        @document FileDescriptor """
        ## FileDescriptor

        Stand-in for a file-location on disk. There is no guarantee that file
        pointer to is valid or even exists. No method acting on `FileDescriptor`
        can modify the underyling file on disk, `FileDescriptor` is read-only.

        $CONSTRUCTORS
        ```
        FileDescriptor(path::String)
        ```
        """

        @document create_from_path!(::FileDescriptor, ::String) """
        ```
        create_from_path!(::FileDescriptor, path::String) -> Bool
        ```
        Create as file descriptor of file or folder at given path. If the location contains a valid
        file or folder `true` will be returned.
        """

        @document create_from_uri!(::FileDescriptor, ::String) """
        ```
        create_from_uri!(::FileDescriptor, uri::String) -> Bool
        ```
        Create as file descriptor of file or folder at given URI. If the location contains a valid file
        or folder, `true` will be returned.
        
        """
        @document get_name(::FileDescriptor) """
        ```
        get_name(::FileDescriptor) -> String
        ```
        Get the file name component of the file pointed to by the file descriptor.
        """

        @document get_path """
        ```
        get_path(::FileDescriptor) -> String
        ```

        Get absolute path of the file pointed to by the file descriptor.
        """

        @document get_uri """
        ```
        get_uri(::FileDescriptor) -> String
        ```

        Get absolute path of the file pointed to by the file descriptor as an URI.
        """

        @document get_file_extension """
        ```
        get_file_extension(::FileDescriptor) -> String
        ```

        Get file extension component of the file pointer to be file descriptor. The result may be an empty string.
        """

        @document get_path_relative_to """
        ```
        get_path_realtive_to(self::FileDescriptor, other::FileDescriptor) -> String
        ```

        Get the relative path from `self` to `other`.
        """

        @document get_parent """
        ```
        get_parent(::FileDescriptor) -> FileDescriptor
        ```

        Get parent folder of the file pointed to be the file descriptor. There is no guarantee that such a folder exists.
        """
       
        @document exists """
        ```
        exists(::FileDescriptor) -> Bool
        ```

        Get whether the file pointer to by the file descriptor is a valid file or folder.
        """

        @document is_folder """
        ```
        is_folder(::FileDescriptor) -> Bool
        ```

        Returns `true` if file exists and is a directory, `false` otherwise.
        """

        @document is_file """
        ```
        is_file(::FileDescriptor) -> Bool
        ```

        Returns `true` if file exists and is not a directory, `false` otherwise.
        """

        @document is_symlink """
        ```
        is_symlink(::FileDescriptor) -> Bool
        ```

        Returns `true` if file exists and is a symlink, `false` otherwise.
        """

        @document read_symlink """
        ```
        read_symlink(::FileDescriptor) -> FileDescriptor
        ```

        If the file is a symlink, follow it and return a file descriptor pointing to the resulting location.
        """

        @document get_content_type """
        ```
        get_content_type(::FileDescriptor) -> String
        ```

        Get the content type, usually as a MIME type identifier.
        """

        @document query_info """
        ```
        query_info(::FileDescriptor, attribute_name::String) -> String
        ```

        Query raw value of file attribute. A list of attribute names is available [here](https://docs.gtk.org/gio/index.html#constants).
        There is no guarantee that all atrributes will have a value. 
        """

        @document FileMonitor """
        ## FileMonitor <: SignalEmitter

        Object that monitors a file location on disk. If the location, which can point
        to a file or folder, is modified in any way, `FileMonitor` will invoke the
        callback registered with `on_file_changed!`.

        $CONSTRUCTORS
        (no pubilc constructors)

        $EXAMPLE
        ```julia
        to_monitor = FileDescriptor("path/to/monitored.txt")
        monitor = create_monitor(to_monitor)
        on_file_changed!(monitor) monitor::FileMonitor, event::FileMonitorEvent, self::FileDescriptor, other::FileDescriptor
            if event == FILE_MONITOR_EVENT_CHANGED
                println("File at " * get_path(self) * " was modified")
            end
        end
        ```
        """

        @document FileMonitorEvent """
        File events recognized by the monitor. See the manual section on `FileMonitor` for more information.

        $ENUM_VALUES
        + `FILE_MONITOR_EVENT_CHANGED`
        + `FILE_MONITOR_EVENT_CHANGES_DONE_HINT`
        + `FILE_MONITOR_EVENT_DELETED`
        + `FILE_MONITOR_EVENT_CREATED`
        + `FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED`
        + `FILE_MONITOR_EVENT_RENAMED`
        + `FILE_MONITOR_EVENT_MOVED_IN`
        + `FILE_MONITOR_EVENT_MOVED_OUT`
        """

        @document on_file_changed! """
        ```
        on_file_changed!(f, ::FileMonitor, [::Data_t]) -> Cvoid
        ```

        Register a callback to be called when the file monitor detects an event. `f` is required to be
        invocable as a function with the following signature:
        ```
        (::FileMonitor, ::FileMonitorEvent, ::FileDescriptor, ::FileDescriptor, [::Data_t]) -> Cvoid
        ```
        Where `::Data_t` is an optional argument containing arbitrary data. If specified, it will be forwarded
        to `f`.
        """

        @document cancel!(::FileMonitor) """
        ```
        cancel!(::FileMontior) -> Cvoid
        ```

        Cancel the monitor, this unregsiters the linked callback and finalizes the underlying monitor.
        """

        @document is_cancelled """
        ```
        is_cancelled(::FileMontior) -> Bool
        ```

        Check whether the current monitor was cancelled.
        """

        @document create_file_at! """
        ```
        create_file_at!(::FileDescriptor, allow_replace::Bool) -> Bool
        ```

        Create a new file at given location. If a file there already exists and `allow_replace` is `true`, that 
        file will be permanently overwritten. Returns `true` if the operation was succesful.
        """

        @document create_directory_at! """
        ```
        create_directory_at!(::FileDescriptor) -> Bool
        ```

        Create folder at given location. Returns `true` if the operation was succesful.
        """
        
        @document delete_at! """
        ```
        delete_at!(::FileDescriptor) -> Bool
        ```

        Permanently delete file at given location. Returns `true` if the operation was succesful.
        """
        
        @document copy! """
        ```
        copy!(from::FileDescriptor, to::FileDescriptor, allow_overwrite::Bool; [make_backup::Bool, follow_symlink::Bool]) -> Bool
        ```

        Copy a file from one location to another. Returns `true` if operator was succesful.

        $ARGUMENTS
        + `from`: Location of the file that will be copied
        + `to`: Location the file should be copied to
        + `allow_overwrite`: If file already exists at `to` location, should it be overwritten
        + `make_backup`: (optional) should backup of `from` be made in its current folder
        + `follow_symlink`: (optiona) should symlinks for `from` or `to` be followed
        """

        @document move! """
        ```
        move!(from::FileDescriptor, to::FileDescriptor, allow_overwrite::Bool; [make_backup::Bool, follow_symlink::Bool]) -> Bool
        ```

        Move a file from one location to another. Returns `true` if operator was succesful.

        $ARGUMENTS
        + `from`: Location of the file that will be moved
        + `to`: Location the file should be moved to
        + `allow_overwrite`: If file already exists at `to` location, should it be overwritten
        + `make_backup`: (optional) should backup of `from` be made in its current folder
        + `follow_symlink`: (optiona) should symlinks for `from` or `to` be followed
        """

        @document move_to_trash! """
        ```
        move_to_trash!(::FileDescriptor) -> Bool
        ```
        Move file at given location to the system trash bin. Unlike `delete_at!`, this operation can be undone by the user.
        """
        
    ####### file_chooser.jl

        @document FileFilter """
        ## FileFilter <: SignalEmitter

        Object represented a filter that allows certain files to pass through.

        $CONSTRUCTORS
        ```
        FileFilter(name::String)
        ```
        """

        @document add_allowed_pattern! """
        ```
        add_allowed_pattern!(::FileFilter, pattern::String) -> Cvoid
        ```
        Add a shell-style glob of allowed patterns to the filter.

        $EXAMPLE
        ```julia
        filter = FileFilter("Julia Files")
        add_allowed_pattern!(filter, "*.jl")
        ```
        """
        
        @document add_allow_all_supported_image_formats! """
        ```
        add_allow_all_supported_image_formats!(::FileFilter) -> Cvoid
        ```
        Let any file that can be loaded as an `Image` through the filter.
        """
        
        @document add_allowed_suffix! """
        ```
        add_allowed_suffix(::FileFilter, suffix_without_dot::String) -> Cvoid
        ```
        Add a file extension to the list of allowed files.

        $EXAMPLE
        ```julia
        filter = FilFilter("Julia Files")
        add_allowed_suffix!(filter, "jl") # without dot
        ```
        """
        
        @document add_allowed_mime_type! """
        ```
        add_allowed_mim_type!(::FileFilter, mime_type::String) -> Cvoid
        ```
        Allow any file whos MIME type is equal to the one specified through the filter.
        """
        
        @document FileChooserAction """
        Mode of `FileChoser`. Determines layout, behavior, and which types of objects users can select.

        $ENUM_VALUES
        + `FILE_CHOOSER_ACTION_OPEN_FILE`
        + `FILE_CHOOSER_ACTION_OPEN_MULTIPLE_FILES`
        + `FILE_CHOOSER_ACTION_SELECT_FOLDER`
        + `FILE_CHOOSER_ACTION_SELECT_MULTIPLE_FOLDERS`
        + `FILE_CHOOSER_ACTION_SAVE`
        """

        @document FILE_CHOOSER_ACTION_SAVE """
        User can choose a location and a file name, entered via a name bar.
        """

        @document FILE_CHOOSER_ACTION_OPEN_FILE """
        No name bar, user has to select exaclty one file (that is not a folder).
        """

        @document FILE_CHOOSER_ACTION_OPEN_MULTIPLE_FILES """
        No name bar, user has to select one or more files (none of which are a folder).
        """

        @document FILE_CHOOSER_ACTION_SELECT_FOLDER """
        No name bar, user has to select exactly one folder (that is not a file).
        """

        @document FILE_CHOOSER_ACTION_SELECT_MULTIPLE_FOLDERS """
        No name bar, user has to select exactly one r moder folders (none of which are a file).
        """

        @document FileChoser """
        ## FileChooser <: SignalEmitter

        Dialog used to select a file or folder. Its layout is pre-determined.

        $CONSTRUCTORS
        ```julia
        FileChooser(::FileChoserActin, [title::String])
        ```

        $EXAMPLE
        ```julia
        chooser = FileChooser(FILE_CHOOSER_ACTION_SAVE, "Save as...")

        on_accept!(chooser) do x::FileChooser, files::Vector{FileDescriptor}
            println("User selected: ", get_path(files[1])
        end

        on_cancel!(chooser) do x::FileChooser
            println("cancelled.")
        end

        present!(chooser)
        ```
        """

        @document on_accept! """
        ```
        on_accept!(f, ::FileChooser, [::Data_t]) -> Cvoid
        ```

        Register a callback to be called when the user presses the "accept" button. `f` is
        required to be invocable as a functio with signature 
        ```
        (::FileChooser, files::Vector{FileDescriptor}, [::Data_t]) -> Cvoid
        ```
        
        Where `files` are all user seleced files. This vector may be empty, or contain one or more files depending
        on the `FileChooserAction` specified during the constructor of `FileChooser`.

        `Data_t` is optional arbitrary data that will be forwarded to `f`.

        $EXAMPLE
        ```julia
        chooser = FileChooser(FILE_CHOOSER_ACTION_OPEN_MULTIPLE_FILES)
        on_accept!(chooser) do x::FileChooser, files::Vector{FileDescriptor}

            println("Selected Files:")
            for file in files
                println(get_path(file))
            end
        end
        present!(chooser)
        ```
        """

        @document on_cancel! """
        ```
        on_cancel!(f, ::FileChooser, [::Data_t]) -> Cvoid
        ```

        Register a callback to be called when the user presses the "cancel" button or the dialog is closed otherwise. 
        `f` is required to be invocable as a functio with signature 
        ```
        (::FileChooser, [::Data_t]) -> Cvoid
        ```
        
        Where `Data_t` is optional arbitrary data that will be forwarded to `f`. Note that the `FileChooser` instance
        should not be modified from within this callback, as it is automatically closed when `f` exits.

        $EXAMPLE
        ```julia
        chooser = FileChooser(FILE_CHOOSER_ACTION_OPEN_MULTIPLE_FILES)
        on_accept!(chooser) do x::FileChooser, files::Vector{FileDescriptor}

            println("Selected Files:")
            for file in files
                println(get_path(file))
            end
        end
        present!(chooser)
        ```
        """
        
        @document set_accept_label! """
        ```
        set_accept_label!(::FileChooser, label::String) -> Cvoid
        ```

        Override the label for the "accept" button.
        """
        
        @document get_accept_label """
        ```
        get_accept_label(::FileChooser) - String
        ```

        Get label for the "accept" button.
        """
        
        @document present!(::FileChooser) """
        ```
        present!(::FileChooser) -> Cvoid
        ```

        Realize the dialog and present it to the user.
        """
        
        @document cancel!(::FileChooser) """
        ```
        cancel!(::FileChooser) -> Cvoid
        ```

        Close the dialog and invoked the function registered using `on_cancel!`
        """
        
        @document set_is_modal!(::FileChooser) """
        ```
        set_is_modal!(::FileChooser, ::Bool) -> Cvoid
        ```

        Set whether the file chooser dialog should pause all other active windows when presented.
        """
        
        @document get_is_modal(::FileChooser) """
        ```
        get_is_modal!(::FileChooser) -> Bool
        ```

        Get whether the file chooser dialog pauses all other active windows when presented.
        """

####### image_display.jl
        
        @document ImageDisplay """
        ## ImageDisplay <: Widget

        Widget displaying immutable image data. Only suitable for static images, using `Texture` 
        when the images contents are supposed to change frequently.

        $CONSTRUCTORS
        ```
        ImageDisplay(path::String)
        ImageDisplay(image::Image)
        ImageDisplay(icon::Icon)
        ```
        """
        
        @document create_from_file!(::ImageDisplay) """
        ```
        create_from_file!(::ImageDisplay, path::String) -> Bool
        ```

        Create from image on disk. Returns `true` if loading was succesful.

        ## Support Image Formats

        | Format Name             | File Extensions |
        |-------------------------|-----------------|
        | PNG                     | `.png`  |
        | JPEG                    | `.jpeg` `.jpe` `.jpg`  |
        | JPEG XL image           | `.jxl`  |
        | Windows Metafile        | `.wmf` `.apm`  |
        | Windows animated cursor | `.ani`  |
        | BMP                     | `.bmp`  |
        | GIF                     | `.gif`  |
        | MacOS X icon            | `.icns`  |
        | Windows icon            | `.ico` `.cur`  |
        | PNM/PBM/PGM/PPM         | `.pnm` `.pbm` `.pgm` `.ppm`  |
        | QuickTime               | `.qtif` `.qif`  |
        | Scalable Vector Graphics | `.svg` `.svgz` `.svg.gz`  |
        | Targa                   | `.tga` `.targa`  |
        | TIFF                    | `.tiff` `.tif`  |
        | WebP                    | `.webp`  |
        | XBM                     | `.xbm`  |
        | XPM                     | `.xpm`  |
        """
        
        @document create_from_icon! """
        ```
        create_from_icon!(::ImageDisplay, ::Icon) -> Cvoid
        ```
        Initializes image data with vector graphics of an icon.
        """
        
        @document create_from_image! """
        ```
        create_from_image!(::ImageDisplay, ::Image) -> Cvoid
        ```
        Initialize image data from `Image`. Note that modifying the `Image` does not 
        modify the `ImageDisplay`, after this call both objects are not connected in any way.
        """
        
        @document create_as_file_preview! """
        ```
        create_as_file_preview!(::ImageDisplay, ::FileDescriptor) -> Cvoid
        ```
        If the underlying file is an image, create a preview of that image, otherwise create a preview of the
        files icon. This operation cannot file, if the file does not exist, a "not found" icon is shown.
        """

        @document clear!(::ImageDisplay) """
        ```
        clear!(::ImageDisplay) -> Cvoid
        ```
        Clear the image data, after this, the `ImageDisplay` will have a resolution of 0px.
        """

        @document set_scale!(::ImageDisplay) """
        ```
        set_scale!(::ImageDisplay, scale::Integer) -> Cvoid
        ```
        Multiply the image displays size with a constant integer > 0.
        """

        @document Entry """
        ## Entry <: Widget

        Single-line text entry.

        $CONSTRUCTORS
        ```
        Entry()
        ```
        $SIGNALS
        $(generate_signal_table(:Entry, 
            :activate,
            :text_changed
        ))

        $EXAMPLE
        ```julia
        entry = Entry()
        set_text!(entry, "Enter Message")
        connect_signal_activate!(entry) do x::Entry
            println(get_text(x))
        end
        """

        @document get_text(::Entry) """
        ```
        get_text(::Entry) -> String
        ```
        Access the current state of the entries text buffer.
        """

        @document set_text!(::Entry) """
        ```
        set_text!(::Entry, ::String) -> Cvoid
        ```
        Overwrite the entries text buffer.
        """

        @document set_max_length! """
        ```
        set_max_length!(::Entry, n_characters::Integer) -> Cvoid
        ```
        Set the width of the entry such that given number of characters can be displays at once, or `-1` 
        for no maximum width.
        """

        @document get_max_length """
        ```
        get_max_length(::Entry) -> Signed
        ```
        Get number of allowed characters, or `-1` if any number is allowed.
        """

        @document set_has_frame!(::Entry, ::Bool) """
        ```
        set_has_frame!(::Entry, ::Bool) -> Cvoid
        ```
        Set whether the entry itself should show its graphical element. If `false`, the text inside
        the entry is still displayed.
        """

        @document get_has_frame(::Entry) """
        ```
        get_has_frame!(::Entry) -> Bool
        ```
        Get whether the frame of the entry is displayed.
        """
        @document set_text_visible! """
        ```
        set_text_visible!(::Entry, enter_password_mode::Bool) -> Cvoid
        ```
        If `true`, all characters will be replaced with a placeholder. This is useful 
        when entering passwords or other sensitive information.
        """

        @document get_text_visible """
        ```
        get_text_visible(::Entry) -> Bool
        ```
        Get whether entry is in "password mode".
        """

        @document set_primary_icon! """
        ```
        set_primary_icon!(::Entry, ::Icon) -> Cvoid
        ```
        Set icon displayed on the left of the entry.
        """
        @document remove_primary_icon! """
        ```
        remove_primary_icon!(::Entry) -> Cvoid
        ```
        Clear left icon of entry.
        """

        @document set_secondary_con! """
        ```
        set_secondary_icon!(::Entry, ::Icon) -> CVoid
        ```
        Set icon displayed on the right of the entry.
        """

        @document remove_secondary_icon! """
        ```
        remove_secondar_icon!(::Entry) -> Cvoid
        ```
        Clear right icon of entry.
        """

####### expander.jl

        @document Expander """
        ## Expander <: Widget

        Widget with a collapsible label and child. If the label is clicked, the child will be revealed.


        Note that this widget should not be used to display a collapsible list, for exampe a folder structure. Use `ListView`
        for this purpose insteand.

        $SIGNALS
        $(generate_signal_table(:Expander,
            :activate
        ))
        """

        @document set_child!(::Expander, ::Widget) """
        ```
        set_child!(::Expander, ::Widget) -> Cvoid
        ```
        Set child widget of expander, this is the widget that may be hidden or revealed by clicking the label.
        """

        @document remove_child!(::Expander) """
        ```
        remove_child!(::Expander) -> Cvoid
        ```
        Clear child widget of expander.
        """

        @document set_label_widget!(::Expander, ::Widget) """
        ```
        set_label_widget!(::Expander, ::Widget) -> Cvoid
        ```
        Set widget used as the label of an expander.
        """

        @document remove_label_widget!(::Expander) """
        ```
        remove_label_widget!(::Expander) -> Cvoid
        ```
        Clear label widget of expander.
        """

    ####### fixed.jl

        @document Fixed """
        ## Fixed <: Widget

        Widget that positions its children at hard-coded positions. Use of `Fixed` is
        usually discouraged, as it breaks the convention of automatically determining widget 
        layouts.

        $CONSTRUCTORS
        ```
        Fixed()
        ``` 
        """

        @document add_child!(::Fixed, ::Widget, position::Vector2f) """
        ```
        add_child!(::Fixed, ::Widget, position::Vector2f) -> Cvoid
        ```
        Add a child at given position. Coordinates are in `([0, width], [0, height])`, where `width` and `height`
        are the allocated size of `Fixed`.
        """

        @document remove_child!(::Fixed, ::Widget) """
        ```
        remove_child!(::Fixed, ::Widget) -> Cvoid
        ```
        Remove widget from fixed.
        """

        @document set_child_position! """
        ```
        set_child_position!(::Fixed, ::Widget, position::Vector2f) -> Cvoid
        ```
        Move child to given position. Coordinates are in `([0, width], [0, height])`, where `width` and `height`
        are the allocated size of `Fixed`.
        """

        @document get_child_position """
        ```
        get_child_position(::Fixed, ::Widget) -> Vector2f
        ```
        Get current position of child, or `(0, 0)` if widget was not yet added with `add_child!`.
        """

     ####### level_bar.jl   

        @document LevelBar """
        ## LevelBar <: Widget

        Widget displaying fraction as a horizontal or vertical bar. Bar changes color when it reaches 75%,
        markers with a name can be added at any specific value of the bar.

        $CONSTRUCTORS
        ```
        LevelBar(min_value::AbstractFloat, max_value::AbstractFloat)
        ```

        $EXAMPLE
        ```julia
        bar = LevelBar(0, 100)
        add_marker!(bar, "75%", 75)
        set_value!(bar, 76)
        ```
        """

        @document add_marker! """
        ```
        add_marker!(::LevelBar, name::String, value::AbstractFloat) -> Cvoid
        ```
        Add a marker at specified position. The markers name has to be unique.
        """

        @document remove_marker! """
        ```
        remove_marker!(::LevelBar, name::String) -> Cvoid
        ```
        Remove mark with given label.
        """

        @document set_inverted! """
        ```
        set_inverted!(::LevelBar, ::Bool) -> Cvoid
        ```
        Set whether the level bar should fill from left-to-right or right-to-left if horizontal, bottom-to-top or top-to-bottom if vertical.
        """

        @document LevelBarMode """
        Display mode of a `LevelBar`

        $ENUM_VALUES
        + `LEVEL_BAR_MODE_CONTINUOUS`
        + `LEVEL_BAR_MODE_DISCRETE`
        """

        @document LEVEL_BAR_MODE_CONTINUOUS """
        Level bar displays a floating point as a single bar.
        """

        @document LEVEL_BAR_MODE_DISCRETE """
        LevelBar displays an integer with multiple segments.
        """

        @document set_mode! """
        ```
        set_mode!(::LevelBar, ::LevelBarMode) -> Cvoid
        ```
        Set whether the levelbar displays its values as continuous or discrete.
        """

        @document get_mode! """
        ```
        get_mode(::LevelBar, ::LevelBarMode) -> Cvoid
        Get whether the levelbar displays  its values as continuous or discrete.
        ```
        """

        @document set_min_value! """
        ```
        set_min_value!(::LevelBar, ::AbstractFloat) -> Cvoid
        ```
        Set lower bound of the range expressed by level bar.
        """

        @document set_max_value """
        ```
        set_max_value!(::LevelBar, ::AbstractFloat) -> Cvoid
        ```
        Set upper bound of the range expressed by level bar.
        """

        @document get_min_value """
        ```
        get_min_value(::LevelBar) -> Float32
        ```
        Get lower bound of the range expressed by level bar.
        """

        @document get_max_value """
        ```
        get_max_value(::LevelBar) -> Float32
        ```
        Get upper bound of the range expressed by level bar.
        """

        @document set_value """
        ```
        set_value!(::LevelBar, ::AbstractFloat) -> Cvoid
        ```
        Set current value of the range expressed by level bar.
        """

        @document get_value """
        ```
        get_value(::LevelBar) -> Float32
        ```
        Get current value of the range expressed by level bar.
        """
        
        @document set_orientation!(::Levelbar, ::Orientation) """
        ```
        set_orientation!(::LevelBar, ::Orientation) -> Cvoid
        ```
        Set whether the level bar should be horizontal or vertical.
        """

        @document get_orientation(::LevelBar) """
        ```
        get_orientation(::LevelBar) -> Orientation
        ```
        Get whether the level bar is horizontal or vertical.
        """

####### label.jl

        @document Label """
        ## Label <: Widget

        Displays static text, both single- and multi-line. Supports [pango markup](https://docs.gtk.org/Pango/pango_markup.html).

        $CONSTRUCTORS
        ```
        Label()
        Label(::String)
        ```
        """

        @document JustifyMode """
        Horizontal distribution of words for multi-line text.

        $ENUM_VALUES
        + `JUSTIFY_MODE_LEFT`
        + `JUSTIFY_MODE_CENTER`
        + `JUSTIFY_MODE_RIGHT`
        + `JUSTIFY_MODE_FILL`
        """

        @document EllisizeMode """
        Determines where an ellipses (`...`) is place when a single line of text 
        exceeds the allocated width of the `Label` displaying it.

        $ENUM_VALUES
        + `ELLIPSIZE_MODE_NONE`
        + `ELLIPSIZE_MODE_START`
        + `ELLIPSIZE_MODE_MIDDLE`
        + `ELLIPSIZE_MODE_END`
        """

        @document LabelWrapMode """
        Determines at which point in a line a line break will be inserted, if text 
        wrapping is enabled

        $ENUM_VALUES
        + `LABEL_WRAP_MODE_NONE`
        + `LABEL_WRAP_MODE_ONLY_ON_WORD`
        + `LABEL_WRAP_MODE_ONLY_ON_CHAR`
        + `LABEL_WRAP_MODE_WORD_OR_CHAR`
        """

        @document set_text!(::Label, ::String) """
        ```
        set_text!(::Label, ::String) -> Cvoid
        ```
        Overwrite text displayed by label. Supports [pango markup](https://docs.gtk.org/Pango/pango_markup.html).
        """

        @document get_text(::Label) """
        ```
        get_text!(::Label) -> String
        ```
        Get raw content of text buffer displayed by label.
        """

        @document set_use_markup! """
        ```
        set_us_markup!(::Label, ::Bool) -> Cvoid
        ```
        Set whether [pango markup](https://docs.gtk.org/Pango/pango_markup.html) should be enabled. `true` by default.
        """

        @document get_use_markup """
        ```
        get_us_markup(::Label) -> Bool
        ```
        Get whether [pango markup](https://docs.gtk.org/Pango/pango_markup.html) is enabled.
        """

        @document set_ellipsize_mode! """
        ```
        set_ellipsize_mode!(::Label, ::EllipsizeMode) -> Cvoid
        ```
        Set ellipsize mode. If mode is anything other than `ELLIPSIZE_MODE_NONE`, ellipsizing will be enabled.
        """

        @document get_ellipsize_mode """
        ```
        get_ellipsize_mode(::Label) -> EllipsizeMode
        ```
        Get ellipsize mode used by label.
        """

        @document set_wrap_mode! """
        ```
        set_wrap_mode!(::Label, ::WrapMode) -> Cvoid
        ```
        Set wrap mode. If mode is anything other than `LABEL_WRAP_MODE_NONE`, wrapping will be enabled.
        """

        @document set_justify_mode!(::Label) """
        ```
        set_justify_mode!(::Label, ::JustifyMode) -> Cvoid
        ```
        Set justify mode of label, `JUSTIFY_MODE_LEFT` by default.
        """

        @document get_justify_mode(::Label) """
        ```
        get_justify_mode(::Label) -> ::JustifyMode
        ```
        Get justify mode of label.
        """

        @document set_max_width_chars! """
        ```
        set_max_width_chars!(::Label, n::Integer) -> Cvoid
        ```
        Set length of label based on the number of characters that shoud be displayed per line, or `-1` for no maximum lenght.
        """

        @document get_max_width_chars """
        ```
        get_max_width_chars(::Label) -> Integer
        ```
        Get length of label based on the number of characters that shoud be displayed per line, or `-1` if no maximum length was set.

        """
        @document set_x_alignment! """
        ```
        set_x_alignment(::Label, x::AbstractFloat) -> Cvoid
        ```
        Set horizontal offset of text.
        """

        @document get_x_alignment """
        ```
        get_x_alignment(::Label) -> AbstractFloat
        ```
        Get horizontal offset of text.
        """

        @document set_y_alignment! """
        ```
        set_y_alignment!(::Label, y::AbstractFloat) -> Cvoid
        ```
        Set vertical offset of text.
        """

        @document get_y_alignment """
        ```
        get_y_alignment(::Label) -> AbstractFloat
        ```
        Get vertical offset of text.
        """

        @document set_selectable! """
        ```
        set_selectable!(::Label, ::Bool) -> Cvoid
        ```
        Set whether the user can select the label with their cursor.
        """

        @document get_selectable """
        ```
        get_selectable(::Label) -> Bool
        ```
        Get whether the user can select the label with their cursor.
        """

    ####### text_view.jl

        @document TextView """
        ## TextView <: Widget

        Multi-line text entry. Supports basic text-editor functions such as undo/redo.

        $CONSTRUTORS
        ```
        TextView()
        ```

        $SIGNALS
        $(generate_signal_table(:TextView,
            :text_changed
        ))
        """

        @document get_text(::TextView) """
        ```
        get_text(::TextView) -> String
        ```
        Get state of internal text buffer.
        """

        @document set_text!(::TextView) """
        ```
        set_text!(::TextView, ::String) -> Cvoid
        ```
        Override internal text buffer.
        """

        @document set_cursor_visible! """
        ```
        set_cursor_visible!(::TextView, ::Bool) -> Cvoid
        ```
        Set whether the text caret should be visible to the user.
        """

        @document get_cursor_visible """
        ```
        get_cursor_visible(::TextView) -> Bool
        ```
        Get whether the text caret is visible to the user.
        """

        @document undo! """
        ```
        undo!(::TextView) -> Cvoid
        ```
        Trigger an "undo" action.
        """

        @document redo! """
        ```
        redo!(::TextView) -> Cvoid
        ```
        Trigger a "redo" action. May fail if no action is on the undo stack.
        """

        @document set_was_modified! """
        ```
        set_was_modified!(::TextView, ::Bool) -> Cvoid
        ```
        Mark the text buffer as modified. 
        """

        @document get_was_modified """
        ```
        get_was_modified(::TextView) -> Bool
        ```
        Get whether the text buffer was marked as modified.
        """

        @document set_editable! """
        ```
        set_editable!(::TextView, ::Bool) -> Cvoid
        ```
        Set whether the user can change the text in the text view.
        """

        @document get_editable """
        ```
        get_editable(::TextView) -> Bool
        ```
        Get whether the user can change the text in the text view.
        """

        @document set_justify_mode!(::TextView, ::JustifyMode) """
        ```
        set_justify_mode!(::TextView, ::JustifyMode) -> Cvoid
        ```
        Set justify mode of text.
        """

        @document get_justify_mode(::TextView) """
        ```
        get_justify_mode(::TextView) -> JustifyMode 
        ```
        Get justify mode of text.
        """

        @document set_top_margin! """
        ```
        set_top_margin!(::TextView, ::AbstractFloat) -> Cvoid
        ```
        Set upper margin, distance between the top of the text and the text views frame.
        """

        @document get_top_margin """
        ```
        get_top_margin(::TextView) -> AbstractFloat
        ```
        Get upper margin, distance between the top of the text and the text views frame.
        """

        @document set_bottom_margin! """
        ```
        set_bottom_margin!(::TextView, ::AbstractFloat) -> Cvoid
        ```
        Set lower margin, distance between the bottom of the text and the text views frame.
        """

        @document get_bottom_margin """
        ```
        get_bottom_margin(::TextView) -> AbstractFloat
        ```
        Get lower margin, distance between the bottom of the text and the text views frame.
        """

        @document set_left_margin! """
        ```
        set_left_margin!(::TextView, ::AbstractFloat) -> Cvoid
        ```
        Set left margin, distance between the left side  of the text and the text views frame.
        """

        @document get_left_margin """
        ```
        get_left_margin(::TextView) -> AbstractFloat
        ```
        Get left margin, distance between the left side of the text and the text views frame.
        """

        @document set_right_margin! """
        ```
        set_right_margin!(::TextView, ::AbstractFloat) -> Cvoid
        ```
        Set right margin, distance between the right side  of the text and the text views frame.
        """

        @document get_right_margin """
        ```
        get_right_margin(::TextView) -> AbstractFloat
        ```
        Get right margin, distance between the right side of the text and the text views frame.
        """

    ####### frame.jl

        @document Frame """
        ## Frame <: Widget

        Widget that draws a solid border with rounded corners around the allocated area of its child. 
        An optional label can be inserted on the top side of the frame.

        $CONSTRUCTORS
        ```
        Frame()
        ```
        """
        
        @document set_child!(::Frame, ::Widget) """
        ```
        set_child!(::Frame, ::Widget) -> Cvoid
        ```
        Set frames singular child.
        """

        @document set_label_widget! """
        ```
        set_label_widget!(::Frame, ::Widget) -> Cvoid
        ```
        Set frames label widget.
        """

        @document remove_child!(::Frame) """
        ```
        remove_child!(::Frame) -> Cvoid
        ```
        Clear frames singular child.
        """

        @document remove_label_widget(::Frame) """
        ```
        remove_label_widget!(::Frame) -> Cvoid
        ```
        Clear frames label widget.
        """

        @document set_label_x_alignment """
        ```
        set_label_x_alignment(::Frame, x::AbstractFloat)) -> Cvoid
        ```
        Set horizontal alignment of frames labl widget, in [0, 1].
        """

        @document get_label_x_alignment """
        ```
        get_label_x_alignment(::Frame) -> AbstractFloat
        ```
        Get horizontl alignment of the frames label widget.
        """

####### overlay.jl

    
        @document Overlay """
        ## Overlay <: Widget
        Widget that arranges a number of children in layers on top of its main child. If two 
        interactable widgets overlap, only the "upper" widget will be interactable.

        $CONSTRUCTORS
        ```
        Overlay()
        ```
        """

        @document set_child!(::Overlay, ::Widget) """
        ```
        set_child!(::Overlay, ::Widget) -> Cvoid
        ```
        Set the main child of the overlay. An overlay can only have one main child at a time
        """

        @document remove_child!(::Overlay) """
        ```
        remove_child!(::Overlay) -> Cvoid
        ```
        Clear the main chlid. Overlaid children are unaffected by this.
        """

        @document add_overlay!"""
        ```
        add_overlay!(::Overlay, ::Widget) -> Cvoid
        ```
        Add an overlay, the overlaid widgets will be displayed in the order they are added, 
        where the first added overlay widget will be displayed as the lower-most layer.
        """

        @document remove_overlay! """
        ```
        remove_overlay!(::Overlay, ::Widget) -> Cvoid
        ```
        """

####### relative_position.jl

        @document RelativePosition """
        Declares position of an object relative to another

        $ENUM_VALUES
        + `RELATIVE_POSITION_ABOVE`
        + `RELATIVE_POSITION_BELOW`
        + `RELATIVE_POSITION_LEFT_OF`
        + `RELATIVE_POSITION_RIGHT_OF`
        """
        
####### menu_model.jl

        @document MenuModel """
        ## MenuMode <: SignalEmitter

        Model managing a list of menu items. The item type 
        is determined based on which function was used to add the item.

        Widgets like `MenuBar` and `PopoverMenu` can be used to display
        the menu model.

        See the manual chapter on menus for more information.

        $CONSTRUCTORS
        ```
        MenuModel()
        ```

        $SIGNALS
        $(generate_signal_table(:MenuModel,
            :items_changed   
        ))
        """

        @document add_action! """
        ```
        add_action!(::MenuModel, label::String, action::Action) -> Cvoid
        ```
        Add an "action" type item to the menu model. This will create a button with 
        the given label. When clicked by the user, the action will trigger.
        """

        @document add_widget! """
        ```
        add_widget!(::MenuModel, ::Widget) -> Cvoid
        ```
        Add a "widget" type item to the menu model. This item will display the widget 
        inside the menu. Widget should be interactable. 
        """

        @document add_icon! """
        ```
        add_icon!(::MenuModel, ::Icon) -> Cvoid
        ```

        Add an "icon" type item to the menu model. A menu item can only have a label or and icon, not both. 
        To simulat an item with both an icon and label, create a `Box` with both, then make them a "widget" type
        menu item        
        """

        @document SectionFormat """
        Custom formatting for "section" type menu model items.

        $ENUM_VALUES
        + `SECTION_FORMAT_NORMAL`
        + `SECTION_FORMAT_HORIZONTAL_BUTTONS`
        + `SECTION_FORMAT_HORIZONTAL_BUTTONS_LEFT_TO_RIGHT`
        + `SECTION_FORMAT_HORIZONTAL_BUTTONS_RIGHT_TO_LEFT`
        + `SECTION_FORMAT_CIRCULAR_BUTTONS`
        + `SECTION_FORMAT_INLINE_BUTTONS`
        """

        @document add_section! """
        ```
        add_section!(self::MenuModel, section_title::String, section::MenuModel, [section_format::SectionFormat]) -> Cvoid
        ```
        Add a "section" type item to the menu model. This item will be another menu, displayed in-line. It has a 
        title, frame, and all items inside the `section` menu model will be accessible from view of `self`.

        If `section_format` is anything other than `SECTION_FORMAT_NORMAL`, the default value, users should take care
        that all items inside the `section` menu model are "action" or "icon" type items.
        """
        
        @document add_submenu! """
        ```
        add_submenu!(self::MenuModel, title::String, submenu::MenuModel) -> Cvoid
        ```
        Add a "submenu" type item. This item will appear as a single item in `self`, when clicked, it reveals a new menu
        view based on `subumenu`.
        """

###### menubar.jl

        @document MenuBar """
        ## MenuBar <: Widget

        Menu view that display the menu as an application menu bar. The `MenuModel` instance
        used for the construction of this widget has to satisfy the following properties:
            + all top-level items of the menu model are submenu-type items
        
        For more information, see the manual chapter on menus.
        ```
        MenuBar(::MenuModel)
        ```

        $EXAMPLE
        ```julia
        action = Action("example.action", app);
        set_function!(action) do x::Action
            println("Action Triggered")
        end

        outer = MenuModel()
        inner = MenuModel()
        add_action!(inner, "Trigger Action", action)
        add_submenu!(outer, inner)

        menu_bar = MenuBar(outer)
        ```
        """

####### popover_menu.jl

        @document PopoverMenu """
        ## PopoverMenu <: Widget

        Menu view displaying the menu in a popover that can be revealed. Unlike `MenuBar`, `PopoverMenu`
        can display any `MenuModel`, regardless of organization.
        
        $CONSTRUCTORS
        ```
        PopoverMenu(::MenuModel)
        ```

        $SIGNALS
        $(generate_signal_table(:PopoverMenu,
            :closed
        ))

        $EXAMPLE
        ```julia
        model = MenuModel()
       
        action = Action("example.action", app);
        set_function!(action) do x::Action
            println("Action Triggered")
        end
        add_action!(model, "Trigger Action", action)

        popover_menu = PopoverMenu(model)
        popover_button = PopoverButton()
        set_popover_menu!(popover_button, popover_menu)
        """

###### popover.jl

        @document Popover """
        ## Popover <: Widget

        Specialized window that is always attached to another widget. It has exactly one child·

        $CONSTRUCTORS
        ```
        Popover()
        ```

        $EXAMPLE
        ```julia
        popover = Popover()
        set_child!(Separator())

        popover_button = PopoverButton()
        set_popover!(popover_button, popover)

        # now, when `popover_button` is clicked, popover will be revealed
        ```
        """

        @document popup! """
        ```
        popup!(::Popover) -> Cvoid
        ```
        Reveal the popover to the user.
        """

        @document popdown! """
        ```
        popdown!(::Popover) -> Cvoid
        ```
        Hide the popover.
        """

        @document set_child!(::Popover, ::Widget)"""
        ```
        set_child!(::Popover, ::Widget) -> Cvoid
        ```
        Set the popovers singular child
        """

        @document remove_child!(::Popover)"""
        ```
        remove_child!(::Popover) -> Cvoid
        ```
        Clear singular child of popover.
        """

        @document attach_to!"""
        ```
        attach_to!(::Popover, attachment::Widget) -> Cvoid
        ```
        Attach the popover to the widget. This will determine its position and the "tail" arrow of 
        the popover will point at the widget.
        """

        @document set_relative_position! """
        ```
        set_relative_position!(::Popover, ::RelativePosition) -> Cvoid
        ```
        Set position of popover relative to the widget it is attached to.
        """

        @document get_relative_position """
        ```
        get_relative_position(::Popover) -> RelativePosition
        ```
        Get position of popover relative to the widget it is attached to.
        """

        @document set_autohide! """
        ```
        set_autohide!(::Popover, ::Bool) -> Cvoid
        ```
        Set whether the popover should automatically close when the users cursor exits the allocated area of it or the widget
        it is attached to.
        """

        @document get_autohide """
        ```
        get_autohide(::Popover) -> Bool
        ```
        Get whether the popover automatically closes when the users cursor exits the allocated area of it or the widget
        it is attached to.
        """

        @document set_has_base_arrow! """
        ```
        set_has_base_arrow!(::Popover, ::Bool) -> Cvoid
        ```
        Set whether the "tail" arrow of the popover pointing to the widget it is attach to is visible
        """

        @document get_has_base_arrow """
        ```
        get_has_base_arrow(::Popover) -> Bool
        ```
        Get whether the "tail" arrow of the popover pointing to the widget it is attach to is visible
        """

    
        